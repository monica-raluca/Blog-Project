{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/scheme.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"jXgff\", function(module, exports) {\n\n$parcel$export(module.exports, \"scheme\", () => $e87020e463aa4237$export$3005042704f95a69);\nvar $e87020e463aa4237$var$BUILTIN = \"builtin\", $e87020e463aa4237$var$COMMENT = \"comment\", $e87020e463aa4237$var$STRING = \"string\", $e87020e463aa4237$var$SYMBOL = \"symbol\", $e87020e463aa4237$var$ATOM = \"atom\", $e87020e463aa4237$var$NUMBER = \"number\", $e87020e463aa4237$var$BRACKET = \"bracket\";\nvar $e87020e463aa4237$var$INDENT_WORD_SKIP = 2;\nfunction $e87020e463aa4237$var$makeKeywords(str) {\n    var obj = {}, words = str.split(\" \");\n    for(var i = 0; i < words.length; ++i)obj[words[i]] = true;\n    return obj;\n}\nvar $e87020e463aa4237$var$keywords = $e87020e463aa4237$var$makeKeywords(\"\\u03BB case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\nvar $e87020e463aa4237$var$indentKeys = $e87020e463aa4237$var$makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\nfunction $e87020e463aa4237$var$stateStack(indent, type, prev) {\n    this.indent = indent;\n    this.type = type;\n    this.prev = prev;\n}\nfunction $e87020e463aa4237$var$pushStack(state, indent, type) {\n    state.indentStack = new $e87020e463aa4237$var$stateStack(indent, type, state.indentStack);\n}\nfunction $e87020e463aa4237$var$popStack(state) {\n    state.indentStack = state.indentStack.prev;\n}\nvar $e87020e463aa4237$var$binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\nvar $e87020e463aa4237$var$octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\nvar $e87020e463aa4237$var$hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\nvar $e87020e463aa4237$var$decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\nfunction $e87020e463aa4237$var$isBinaryNumber(stream) {\n    return stream.match($e87020e463aa4237$var$binaryMatcher);\n}\nfunction $e87020e463aa4237$var$isOctalNumber(stream) {\n    return stream.match($e87020e463aa4237$var$octalMatcher);\n}\nfunction $e87020e463aa4237$var$isDecimalNumber(stream, backup) {\n    if (backup === true) stream.backUp(1);\n    return stream.match($e87020e463aa4237$var$decimalMatcher);\n}\nfunction $e87020e463aa4237$var$isHexNumber(stream) {\n    return stream.match($e87020e463aa4237$var$hexMatcher);\n}\nfunction $e87020e463aa4237$var$processEscapedSequence(stream, options) {\n    var next, escaped = false;\n    while((next = stream.next()) != null){\n        if (next == options.token && !escaped) {\n            options.state.mode = false;\n            break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n    }\n}\nconst $e87020e463aa4237$export$3005042704f95a69 = {\n    name: \"scheme\",\n    startState: function() {\n        return {\n            indentStack: null,\n            indentation: 0,\n            mode: false,\n            sExprComment: false,\n            sExprQuote: false\n        };\n    },\n    token: function(stream, state) {\n        if (state.indentStack == null && stream.sol()) // update indentation, but only if indentStack is empty\n        state.indentation = stream.indentation();\n        // skip spaces\n        if (stream.eatSpace()) return null;\n        var returnType = null;\n        switch(state.mode){\n            case \"string\":\n                $e87020e463aa4237$var$processEscapedSequence(stream, {\n                    token: \"\\\"\",\n                    state: state\n                });\n                returnType = $e87020e463aa4237$var$STRING; // continue on in scheme-string mode\n                break;\n            case \"symbol\":\n                $e87020e463aa4237$var$processEscapedSequence(stream, {\n                    token: \"|\",\n                    state: state\n                });\n                returnType = $e87020e463aa4237$var$SYMBOL; // continue on in scheme-symbol mode\n                break;\n            case \"comment\":\n                var next, maybeEnd = false;\n                while((next = stream.next()) != null){\n                    if (next == \"#\" && maybeEnd) {\n                        state.mode = false;\n                        break;\n                    }\n                    maybeEnd = next == \"|\";\n                }\n                returnType = $e87020e463aa4237$var$COMMENT;\n                break;\n            case \"s-expr-comment\":\n                state.mode = false;\n                if (stream.peek() == \"(\" || stream.peek() == \"[\") // actually start scheme s-expr commenting mode\n                state.sExprComment = 0;\n                else {\n                    // if not we just comment the entire of the next token\n                    stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n                    returnType = $e87020e463aa4237$var$COMMENT;\n                    break;\n                }\n            default:\n                var ch = stream.next();\n                if (ch == \"\\\"\") {\n                    state.mode = \"string\";\n                    returnType = $e87020e463aa4237$var$STRING;\n                } else if (ch == \"'\") {\n                    if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n                        if (typeof state.sExprQuote != \"number\") state.sExprQuote = 0;\n                         // else already in a quoted expression\n                        returnType = $e87020e463aa4237$var$ATOM;\n                    } else {\n                        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                        returnType = $e87020e463aa4237$var$ATOM;\n                    }\n                } else if (ch == '|') {\n                    state.mode = \"symbol\";\n                    returnType = $e87020e463aa4237$var$SYMBOL;\n                } else if (ch == '#') {\n                    if (stream.eat(\"|\")) {\n                        state.mode = \"comment\"; // toggle to comment mode\n                        returnType = $e87020e463aa4237$var$COMMENT;\n                    } else if (stream.eat(/[tf]/i)) returnType = $e87020e463aa4237$var$ATOM;\n                    else if (stream.eat(';')) {\n                        state.mode = \"s-expr-comment\";\n                        returnType = $e87020e463aa4237$var$COMMENT;\n                    } else {\n                        var numTest = null, hasExactness = false, hasRadix = true;\n                        if (stream.eat(/[ei]/i)) hasExactness = true;\n                        else stream.backUp(1); // must be radix specifier\n                        if (stream.match(/^#b/i)) numTest = $e87020e463aa4237$var$isBinaryNumber;\n                        else if (stream.match(/^#o/i)) numTest = $e87020e463aa4237$var$isOctalNumber;\n                        else if (stream.match(/^#x/i)) numTest = $e87020e463aa4237$var$isHexNumber;\n                        else if (stream.match(/^#d/i)) numTest = $e87020e463aa4237$var$isDecimalNumber;\n                        else if (stream.match(/^[-+0-9.]/, false)) {\n                            hasRadix = false;\n                            numTest = $e87020e463aa4237$var$isDecimalNumber;\n                        // re-consume the initial # if all matches failed\n                        } else if (!hasExactness) stream.eat('#');\n                        if (numTest != null) {\n                            if (hasRadix && !hasExactness) // consume optional exactness after radix\n                            stream.match(/^#[ei]/i);\n                            if (numTest(stream)) returnType = $e87020e463aa4237$var$NUMBER;\n                        }\n                    }\n                } else if (/^[-+0-9.]/.test(ch) && $e87020e463aa4237$var$isDecimalNumber(stream, true)) returnType = $e87020e463aa4237$var$NUMBER;\n                else if (ch == \";\") {\n                    stream.skipToEnd(); // rest of the line is a comment\n                    returnType = $e87020e463aa4237$var$COMMENT;\n                } else if (ch == \"(\" || ch == \"[\") {\n                    var keyWord = '';\n                    var indentTemp = stream.column(), letter;\n                    /**\n           Either\n           (indent-word ..\n           (non-indent-word ..\n           (;something else, bracket, etc.\n        */ while((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null)keyWord += letter;\n                    if (keyWord.length > 0 && $e87020e463aa4237$var$indentKeys.propertyIsEnumerable(keyWord)) $e87020e463aa4237$var$pushStack(state, indentTemp + $e87020e463aa4237$var$INDENT_WORD_SKIP, ch);\n                    else {\n                        // we continue eating the spaces\n                        stream.eatSpace();\n                        if (stream.eol() || stream.peek() == \";\") // nothing significant after\n                        // we restart indentation 1 space after\n                        $e87020e463aa4237$var$pushStack(state, indentTemp + 1, ch);\n                        else $e87020e463aa4237$var$pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                    }\n                    stream.backUp(stream.current().length - 1); // undo all the eating\n                    if (typeof state.sExprComment == \"number\") state.sExprComment++;\n                    if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n                    returnType = $e87020e463aa4237$var$BRACKET;\n                } else if (ch == \")\" || ch == \"]\") {\n                    returnType = $e87020e463aa4237$var$BRACKET;\n                    if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                        $e87020e463aa4237$var$popStack(state);\n                        if (typeof state.sExprComment == \"number\") {\n                            if (--state.sExprComment == 0) {\n                                returnType = $e87020e463aa4237$var$COMMENT; // final closing bracket\n                                state.sExprComment = false; // turn off s-expr commenting mode\n                            }\n                        }\n                        if (typeof state.sExprQuote == \"number\") {\n                            if (--state.sExprQuote == 0) {\n                                returnType = $e87020e463aa4237$var$ATOM; // final closing bracket\n                                state.sExprQuote = false; // turn off s-expr quote mode\n                            }\n                        }\n                    }\n                } else {\n                    stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                    if ($e87020e463aa4237$var$keywords && $e87020e463aa4237$var$keywords.propertyIsEnumerable(stream.current())) returnType = $e87020e463aa4237$var$BUILTIN;\n                    else returnType = \"variable\";\n                }\n        }\n        return typeof state.sExprComment == \"number\" ? $e87020e463aa4237$var$COMMENT : typeof state.sExprQuote == \"number\" ? $e87020e463aa4237$var$ATOM : returnType;\n    },\n    indent: function(state) {\n        if (state.indentStack == null) return state.indentation;\n        return state.indentStack.indent;\n    },\n    languageData: {\n        closeBrackets: {\n            brackets: [\n                \"(\",\n                \"[\",\n                \"{\",\n                '\"'\n            ]\n        },\n        commentTokens: {\n            line: \";;\"\n        }\n    }\n};\n\n});\n\n\n//# sourceMappingURL=scheme.17565c5e.js.map\n","var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n    SYMBOL = \"symbol\", ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\nvar INDENT_WORD_SKIP = 2;\n\nfunction makeKeywords(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\nvar indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\nfunction stateStack(indent, type, prev) { // represents a state stack object\n  this.indent = indent;\n  this.type = type;\n  this.prev = prev;\n}\n\nfunction pushStack(state, indent, type) {\n  state.indentStack = new stateStack(indent, type, state.indentStack);\n}\n\nfunction popStack(state) {\n  state.indentStack = state.indentStack.prev;\n}\n\nvar binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\nvar octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\nvar hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\nvar decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\nfunction isBinaryNumber (stream) {\n  return stream.match(binaryMatcher);\n}\n\nfunction isOctalNumber (stream) {\n  return stream.match(octalMatcher);\n}\n\nfunction isDecimalNumber (stream, backup) {\n  if (backup === true) {\n    stream.backUp(1);\n  }\n  return stream.match(decimalMatcher);\n}\n\nfunction isHexNumber (stream) {\n  return stream.match(hexMatcher);\n}\n\nfunction processEscapedSequence(stream, options) {\n  var next, escaped = false;\n  while ((next = stream.next()) != null) {\n    if (next == options.token && !escaped) {\n      options.state.mode = false;\n      break;\n    }\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\nexport const scheme = {\n  name: \"scheme\",\n  startState: function () {\n    return {\n      indentStack: null,\n      indentation: 0,\n      mode: false,\n      sExprComment: false,\n      sExprQuote: false\n    };\n  },\n\n  token: function (stream, state) {\n    if (state.indentStack == null && stream.sol()) {\n      // update indentation, but only if indentStack is empty\n      state.indentation = stream.indentation();\n    }\n\n    // skip spaces\n    if (stream.eatSpace()) {\n      return null;\n    }\n    var returnType = null;\n\n    switch(state.mode){\n    case \"string\": // multi-line string parsing mode\n      processEscapedSequence(stream, {\n        token: \"\\\"\",\n        state: state\n      });\n      returnType = STRING; // continue on in scheme-string mode\n      break;\n    case \"symbol\": // escape symbol\n      processEscapedSequence(stream, {\n        token: \"|\",\n        state: state\n      });\n      returnType = SYMBOL; // continue on in scheme-symbol mode\n      break;\n    case \"comment\": // comment parsing mode\n      var next, maybeEnd = false;\n      while ((next = stream.next()) != null) {\n        if (next == \"#\" && maybeEnd) {\n\n          state.mode = false;\n          break;\n        }\n        maybeEnd = (next == \"|\");\n      }\n      returnType = COMMENT;\n      break;\n    case \"s-expr-comment\": // s-expr commenting mode\n      state.mode = false;\n      if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n        // actually start scheme s-expr commenting mode\n        state.sExprComment = 0;\n      }else{\n        // if not we just comment the entire of the next token\n        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n        returnType = COMMENT;\n        break;\n      }\n    default: // default parsing mode\n      var ch = stream.next();\n\n      if (ch == \"\\\"\") {\n        state.mode = \"string\";\n        returnType = STRING;\n\n      } else if (ch == \"'\") {\n        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n          if (typeof state.sExprQuote != \"number\") {\n            state.sExprQuote = 0;\n          } // else already in a quoted expression\n          returnType = ATOM;\n        } else {\n          stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n          returnType = ATOM;\n        }\n      } else if (ch == '|') {\n        state.mode = \"symbol\";\n        returnType = SYMBOL;\n      } else if (ch == '#') {\n        if (stream.eat(\"|\")) {                    // Multi-line comment\n          state.mode = \"comment\"; // toggle to comment mode\n          returnType = COMMENT;\n        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n          returnType = ATOM;\n        } else if (stream.eat(';')) {                // S-Expr comment\n          state.mode = \"s-expr-comment\";\n          returnType = COMMENT;\n        } else {\n          var numTest = null, hasExactness = false, hasRadix = true;\n          if (stream.eat(/[ei]/i)) {\n            hasExactness = true;\n          } else {\n            stream.backUp(1);       // must be radix specifier\n          }\n          if (stream.match(/^#b/i)) {\n            numTest = isBinaryNumber;\n          } else if (stream.match(/^#o/i)) {\n            numTest = isOctalNumber;\n          } else if (stream.match(/^#x/i)) {\n            numTest = isHexNumber;\n          } else if (stream.match(/^#d/i)) {\n            numTest = isDecimalNumber;\n          } else if (stream.match(/^[-+0-9.]/, false)) {\n            hasRadix = false;\n            numTest = isDecimalNumber;\n            // re-consume the initial # if all matches failed\n          } else if (!hasExactness) {\n            stream.eat('#');\n          }\n          if (numTest != null) {\n            if (hasRadix && !hasExactness) {\n              // consume optional exactness after radix\n              stream.match(/^#[ei]/i);\n            }\n            if (numTest(stream))\n              returnType = NUMBER;\n          }\n        }\n      } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n        returnType = NUMBER;\n      } else if (ch == \";\") { // comment\n        stream.skipToEnd(); // rest of the line is a comment\n        returnType = COMMENT;\n      } else if (ch == \"(\" || ch == \"[\") {\n        var keyWord = ''; var indentTemp = stream.column(), letter;\n        /**\n           Either\n           (indent-word ..\n           (non-indent-word ..\n           (;something else, bracket, etc.\n        */\n\n        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n          keyWord += letter;\n        }\n\n        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n          pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n        } else { // non-indent word\n          // we continue eating the spaces\n          stream.eatSpace();\n          if (stream.eol() || stream.peek() == \";\") {\n            // nothing significant after\n            // we restart indentation 1 space after\n            pushStack(state, indentTemp + 1, ch);\n          } else {\n            pushStack(state, indentTemp + stream.current().length, ch); // else we match\n          }\n        }\n        stream.backUp(stream.current().length - 1); // undo all the eating\n\n        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n        returnType = BRACKET;\n      } else if (ch == \")\" || ch == \"]\") {\n        returnType = BRACKET;\n        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n          popStack(state);\n\n          if(typeof state.sExprComment == \"number\"){\n            if(--state.sExprComment == 0){\n              returnType = COMMENT; // final closing bracket\n              state.sExprComment = false; // turn off s-expr commenting mode\n            }\n          }\n          if(typeof state.sExprQuote == \"number\"){\n            if(--state.sExprQuote == 0){\n              returnType = ATOM; // final closing bracket\n              state.sExprQuote = false; // turn off s-expr quote mode\n            }\n          }\n        }\n      } else {\n        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n          returnType = BUILTIN;\n        } else returnType = \"variable\";\n      }\n    }\n    return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n  },\n\n  indent: function (state) {\n    if (state.indentStack == null) return state.indentation;\n    return state.indentStack.indent;\n  },\n\n  languageData: {\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\n    commentTokens: {line: \";;\"}\n  }\n};\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","Object","defineProperty","get","$e87020e463aa4237$export$3005042704f95a69","set","s","enumerable","configurable","$e87020e463aa4237$var$COMMENT","$e87020e463aa4237$var$STRING","$e87020e463aa4237$var$SYMBOL","$e87020e463aa4237$var$ATOM","$e87020e463aa4237$var$NUMBER","$e87020e463aa4237$var$BRACKET","$e87020e463aa4237$var$makeKeywords","str","obj","words","split","i","length","$e87020e463aa4237$var$keywords","$e87020e463aa4237$var$indentKeys","$e87020e463aa4237$var$stateStack","indent","type","prev","$e87020e463aa4237$var$pushStack","state","indentStack","$e87020e463aa4237$var$binaryMatcher","RegExp","$e87020e463aa4237$var$octalMatcher","$e87020e463aa4237$var$hexMatcher","$e87020e463aa4237$var$decimalMatcher","$e87020e463aa4237$var$isBinaryNumber","stream","match","$e87020e463aa4237$var$isOctalNumber","$e87020e463aa4237$var$isDecimalNumber","backup","backUp","$e87020e463aa4237$var$isHexNumber","$e87020e463aa4237$var$processEscapedSequence","options","next","escaped","token","mode","name","startState","indentation","sExprComment","sExprQuote","sol","eatSpace","returnType","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","letter","keyWord","indentTemp","column","propertyIsEnumerable","eol","current","languageData","closeBrackets","brackets","commentTokens","line"],"version":3,"file":"scheme.17565c5e.js.map"}