{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/haskell.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5fDoW\", function(module, exports) {\n\n$parcel$export(module.exports, \"haskell\", () => $3d2ceabb29e2d61e$export$3340b2259fe4061b);\nfunction $3d2ceabb29e2d61e$var$switchState(source, setState, f) {\n    setState(f);\n    return f(source, setState);\n}\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar $3d2ceabb29e2d61e$var$smallRE = /[a-z_]/;\nvar $3d2ceabb29e2d61e$var$largeRE = /[A-Z]/;\nvar $3d2ceabb29e2d61e$var$digitRE = /\\d/;\nvar $3d2ceabb29e2d61e$var$hexitRE = /[0-9A-Fa-f]/;\nvar $3d2ceabb29e2d61e$var$octitRE = /[0-7]/;\nvar $3d2ceabb29e2d61e$var$idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar $3d2ceabb29e2d61e$var$symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar $3d2ceabb29e2d61e$var$specialRE = /[(),;[\\]`{}]/;\nvar $3d2ceabb29e2d61e$var$whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\nfunction $3d2ceabb29e2d61e$var$normal(source, setState) {\n    if (source.eatWhile($3d2ceabb29e2d61e$var$whiteCharRE)) return null;\n    var ch = source.next();\n    if ($3d2ceabb29e2d61e$var$specialRE.test(ch)) {\n        if (ch == '{' && source.eat('-')) {\n            var t = \"comment\";\n            if (source.eat('#')) t = \"meta\";\n            return $3d2ceabb29e2d61e$var$switchState(source, setState, $3d2ceabb29e2d61e$var$ncomment(t, 1));\n        }\n        return null;\n    }\n    if (ch == '\\'') {\n        if (source.eat('\\\\')) source.next(); // should handle other escapes here\n        else source.next();\n        if (source.eat('\\'')) return \"string\";\n        return \"error\";\n    }\n    if (ch == '\"') return $3d2ceabb29e2d61e$var$switchState(source, setState, $3d2ceabb29e2d61e$var$stringLiteral);\n    if ($3d2ceabb29e2d61e$var$largeRE.test(ch)) {\n        source.eatWhile($3d2ceabb29e2d61e$var$idRE);\n        if (source.eat('.')) return \"qualifier\";\n        return \"type\";\n    }\n    if ($3d2ceabb29e2d61e$var$smallRE.test(ch)) {\n        source.eatWhile($3d2ceabb29e2d61e$var$idRE);\n        return \"variable\";\n    }\n    if ($3d2ceabb29e2d61e$var$digitRE.test(ch)) {\n        if (ch == '0') {\n            if (source.eat(/[xX]/)) {\n                source.eatWhile($3d2ceabb29e2d61e$var$hexitRE); // should require at least 1\n                return \"integer\";\n            }\n            if (source.eat(/[oO]/)) {\n                source.eatWhile($3d2ceabb29e2d61e$var$octitRE); // should require at least 1\n                return \"number\";\n            }\n        }\n        source.eatWhile($3d2ceabb29e2d61e$var$digitRE);\n        var t = \"number\";\n        if (source.match(/^\\.\\d+/)) t = \"number\";\n        if (source.eat(/[eE]/)) {\n            t = \"number\";\n            source.eat(/[-+]/);\n            source.eatWhile($3d2ceabb29e2d61e$var$digitRE); // should require at least 1\n        }\n        return t;\n    }\n    if (ch == \".\" && source.eat(\".\")) return \"keyword\";\n    if ($3d2ceabb29e2d61e$var$symbolRE.test(ch)) {\n        if (ch == '-' && source.eat(/-/)) {\n            source.eatWhile(/-/);\n            if (!source.eat($3d2ceabb29e2d61e$var$symbolRE)) {\n                source.skipToEnd();\n                return \"comment\";\n            }\n        }\n        source.eatWhile($3d2ceabb29e2d61e$var$symbolRE);\n        return \"variable\";\n    }\n    return \"error\";\n}\nfunction $3d2ceabb29e2d61e$var$ncomment(type, nest) {\n    if (nest == 0) return $3d2ceabb29e2d61e$var$normal;\n    return function(source, setState) {\n        var currNest = nest;\n        while(!source.eol()){\n            var ch = source.next();\n            if (ch == '{' && source.eat('-')) ++currNest;\n            else if (ch == '-' && source.eat('}')) {\n                --currNest;\n                if (currNest == 0) {\n                    setState($3d2ceabb29e2d61e$var$normal);\n                    return type;\n                }\n            }\n        }\n        setState($3d2ceabb29e2d61e$var$ncomment(type, currNest));\n        return type;\n    };\n}\nfunction $3d2ceabb29e2d61e$var$stringLiteral(source, setState) {\n    while(!source.eol()){\n        var ch = source.next();\n        if (ch == '\"') {\n            setState($3d2ceabb29e2d61e$var$normal);\n            return \"string\";\n        }\n        if (ch == '\\\\') {\n            if (source.eol() || source.eat($3d2ceabb29e2d61e$var$whiteCharRE)) {\n                setState($3d2ceabb29e2d61e$var$stringGap);\n                return \"string\";\n            }\n            if (source.eat('&')) ;\n            else source.next(); // should handle other escapes here\n        }\n    }\n    setState($3d2ceabb29e2d61e$var$normal);\n    return \"error\";\n}\nfunction $3d2ceabb29e2d61e$var$stringGap(source, setState) {\n    if (source.eat('\\\\')) return $3d2ceabb29e2d61e$var$switchState(source, setState, $3d2ceabb29e2d61e$var$stringLiteral);\n    source.next();\n    setState($3d2ceabb29e2d61e$var$normal);\n    return \"error\";\n}\nvar $3d2ceabb29e2d61e$var$wellKnownWords = function() {\n    var wkw = {};\n    function setType(t) {\n        return function() {\n            for(var i = 0; i < arguments.length; i++)wkw[arguments[i]] = t;\n        };\n    }\n    setType(\"keyword\")(\"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\", \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\", \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n    setType(\"keyword\")(\"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n    setType(\"builtin\")(\"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\", \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\", \"*>\", \"**\");\n    setType(\"builtin\")(\"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\", \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\", \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\", \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\", \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\", \"String\", \"True\");\n    setType(\"builtin\")(\"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\", \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\", \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\", \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\", \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\", \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\", \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\", \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\", \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\", \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\", \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\", \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\", \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\", \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\", \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\", \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\", \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\", \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\", \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\", \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\", \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\", \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\", \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\", \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\", \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\", \"zip3\", \"zipWith\", \"zipWith3\");\n    return wkw;\n}();\nconst $3d2ceabb29e2d61e$export$3340b2259fe4061b = {\n    name: \"haskell\",\n    startState: function() {\n        return {\n            f: $3d2ceabb29e2d61e$var$normal\n        };\n    },\n    copyState: function(s) {\n        return {\n            f: s.f\n        };\n    },\n    token: function(stream, state) {\n        var t = state.f(stream, function(s) {\n            state.f = s;\n        });\n        var w = stream.current();\n        return $3d2ceabb29e2d61e$var$wellKnownWords.hasOwnProperty(w) ? $3d2ceabb29e2d61e$var$wellKnownWords[w] : t;\n    },\n    languageData: {\n        commentTokens: {\n            line: \"--\",\n            block: {\n                open: \"{-\",\n                close: \"-}\"\n            }\n        }\n    }\n};\n\n});\n\n\n//# sourceMappingURL=haskell.022a4563.js.map\n","function switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next();  // should handle other escapes here\n    }\n    else {\n      source.next();\n    }\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n    return \"error\";\n  }\n\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n    return \"type\";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return \"integer\";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return \"number\";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = \"number\";\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n    return t;\n  }\n\n  if (ch == \".\" && source.eat(\".\"))\n    return \"keyword\";\n\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return \"variable\"\n  }\n\n  return \"error\";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function(source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      }\n      else if (ch == '-' && source.eat('}')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n      if (source.eat('&')) {\n      }\n      else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n  setState(normal);\n  return \"error\";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return \"error\";\n}\n\n\nvar wellKnownWords = (function() {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++)\n        wkw[arguments[i]] = t;\n    };\n  }\n\n  setType(\"keyword\")(\n    \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n    \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n    \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n  setType(\"keyword\")(\n    \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n  setType(\"builtin\")(\n    \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n    \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n    \"*>\", \"**\");\n\n  setType(\"builtin\")(\n    \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n    \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n    \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n    \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n    \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n    \"String\", \"True\");\n\n  setType(\"builtin\")(\n    \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n    \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n    \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n    \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n    \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n    \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n    \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n    \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n    \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n    \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n    \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n    \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n    \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n    \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n    \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n    \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n    \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n    \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n    \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n    \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n    \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n    \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n    \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n    \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n    \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n    \"zip3\", \"zipWith\", \"zipWith3\");\n\n  return wkw;\n})();\n\nexport const haskell = {\n  name: \"haskell\",\n  startState: function ()  { return { f: normal }; },\n  copyState:  function (s) { return { f: s.f }; },\n\n  token: function(stream, state) {\n    var t = state.f(stream, function(s) { state.f = s; });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n\n  languageData: {\n    commentTokens: {line: \"--\", block: {open: \"{-\", close: \"-}\"}}\n  }\n};\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","Object","defineProperty","get","$3d2ceabb29e2d61e$export$3340b2259fe4061b","set","s","enumerable","configurable","$3d2ceabb29e2d61e$var$smallRE","$3d2ceabb29e2d61e$var$largeRE","$3d2ceabb29e2d61e$var$digitRE","$3d2ceabb29e2d61e$var$hexitRE","$3d2ceabb29e2d61e$var$octitRE","$3d2ceabb29e2d61e$var$idRE","$3d2ceabb29e2d61e$var$symbolRE","$3d2ceabb29e2d61e$var$specialRE","$3d2ceabb29e2d61e$var$whiteCharRE","$3d2ceabb29e2d61e$var$normal","source","setState","eatWhile","f","ch","next","test","eat","t","$3d2ceabb29e2d61e$var$ncomment","type","nest","currNest","eol","$3d2ceabb29e2d61e$var$stringLiteral","match","skipToEnd","$3d2ceabb29e2d61e$var$stringGap","$3d2ceabb29e2d61e$var$wellKnownWords","wkw","setType","i","arguments","length","name","startState","copyState","token","stream","state","w","current","hasOwnProperty","languageData","commentTokens","line","block","open","close"],"version":3,"file":"haskell.022a4563.js.map"}