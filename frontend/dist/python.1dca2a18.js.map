{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/python.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"hwnbV\", function(module, exports) {\n\n$parcel$export(module.exports, \"cython\", () => $cc176a2ad4060fe7$export$dac0ef537f5eb913);\nfunction $cc176a2ad4060fe7$var$wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\nvar $cc176a2ad4060fe7$var$wordOperators = $cc176a2ad4060fe7$var$wordRegexp([\n    \"and\",\n    \"or\",\n    \"not\",\n    \"is\"\n]);\nvar $cc176a2ad4060fe7$var$commonKeywords = [\n    \"as\",\n    \"assert\",\n    \"break\",\n    \"class\",\n    \"continue\",\n    \"def\",\n    \"del\",\n    \"elif\",\n    \"else\",\n    \"except\",\n    \"finally\",\n    \"for\",\n    \"from\",\n    \"global\",\n    \"if\",\n    \"import\",\n    \"lambda\",\n    \"pass\",\n    \"raise\",\n    \"return\",\n    \"try\",\n    \"while\",\n    \"with\",\n    \"yield\",\n    \"in\",\n    \"False\",\n    \"True\"\n];\nvar $cc176a2ad4060fe7$var$commonBuiltins = [\n    \"abs\",\n    \"all\",\n    \"any\",\n    \"bin\",\n    \"bool\",\n    \"bytearray\",\n    \"callable\",\n    \"chr\",\n    \"classmethod\",\n    \"compile\",\n    \"complex\",\n    \"delattr\",\n    \"dict\",\n    \"dir\",\n    \"divmod\",\n    \"enumerate\",\n    \"eval\",\n    \"filter\",\n    \"float\",\n    \"format\",\n    \"frozenset\",\n    \"getattr\",\n    \"globals\",\n    \"hasattr\",\n    \"hash\",\n    \"help\",\n    \"hex\",\n    \"id\",\n    \"input\",\n    \"int\",\n    \"isinstance\",\n    \"issubclass\",\n    \"iter\",\n    \"len\",\n    \"list\",\n    \"locals\",\n    \"map\",\n    \"max\",\n    \"memoryview\",\n    \"min\",\n    \"next\",\n    \"object\",\n    \"oct\",\n    \"open\",\n    \"ord\",\n    \"pow\",\n    \"property\",\n    \"range\",\n    \"repr\",\n    \"reversed\",\n    \"round\",\n    \"set\",\n    \"setattr\",\n    \"slice\",\n    \"sorted\",\n    \"staticmethod\",\n    \"str\",\n    \"sum\",\n    \"super\",\n    \"tuple\",\n    \"type\",\n    \"vars\",\n    \"zip\",\n    \"__import__\",\n    \"NotImplemented\",\n    \"Ellipsis\",\n    \"__debug__\"\n];\nfunction $cc176a2ad4060fe7$var$top(state) {\n    return state.scopes[state.scopes.length - 1];\n}\nfunction $cc176a2ad4060fe7$export$ac69049de4df6700(parserConf) {\n    var ERRORCLASS = \"error\";\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatibility with old, cumbersome config system)\n    var operators = [\n        parserConf.singleOperators,\n        parserConf.doubleOperators,\n        parserConf.doubleDelimiters,\n        parserConf.tripleDelimiters,\n        parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/\n    ];\n    for(var i = 0; i < operators.length; i++)if (!operators[i]) operators.splice(i--, 1);\n    var hangingIndent = parserConf.hangingIndent;\n    var myKeywords = $cc176a2ad4060fe7$var$commonKeywords, myBuiltins = $cc176a2ad4060fe7$var$commonBuiltins;\n    if (parserConf.extra_keywords != undefined) myKeywords = myKeywords.concat(parserConf.extra_keywords);\n    if (parserConf.extra_builtins != undefined) myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3);\n    if (py3) {\n        // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n        var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n        myKeywords = myKeywords.concat([\n            \"nonlocal\",\n            \"None\",\n            \"aiter\",\n            \"anext\",\n            \"async\",\n            \"await\",\n            \"breakpoint\",\n            \"match\",\n            \"case\"\n        ]);\n        myBuiltins = myBuiltins.concat([\n            \"ascii\",\n            \"bytes\",\n            \"exec\",\n            \"print\"\n        ]);\n        var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n        var identifiers = parserConf.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;\n        myKeywords = myKeywords.concat([\n            \"exec\",\n            \"print\"\n        ]);\n        myBuiltins = myBuiltins.concat([\n            \"apply\",\n            \"basestring\",\n            \"buffer\",\n            \"cmp\",\n            \"coerce\",\n            \"execfile\",\n            \"file\",\n            \"intern\",\n            \"long\",\n            \"raw_input\",\n            \"reduce\",\n            \"reload\",\n            \"unichr\",\n            \"unicode\",\n            \"xrange\",\n            \"None\"\n        ]);\n        var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = $cc176a2ad4060fe7$var$wordRegexp(myKeywords);\n    var builtins = $cc176a2ad4060fe7$var$wordRegexp(myBuiltins);\n    // tokenizers\n    function tokenBase(stream, state) {\n        var sol = stream.sol() && state.lastToken != \"\\\\\";\n        if (sol) state.indent = stream.indentation();\n        // Handle scope changes\n        if (sol && $cc176a2ad4060fe7$var$top(state).type == \"py\") {\n            var scopeOffset = $cc176a2ad4060fe7$var$top(state).offset;\n            if (stream.eatSpace()) {\n                var lineOffset = stream.indentation();\n                if (lineOffset > scopeOffset) pushPyScope(stream, state);\n                else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\") state.errorToken = true;\n                return null;\n            } else {\n                var style = tokenBaseInner(stream, state);\n                if (scopeOffset > 0 && dedent(stream, state)) style += \" \" + ERRORCLASS;\n                return style;\n            }\n        }\n        return tokenBaseInner(stream, state);\n    }\n    function tokenBaseInner(stream, state, inFormat) {\n        if (stream.eatSpace()) return null;\n        // Handle Comments\n        if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n        // Handle Number Literals\n        if (stream.match(/^[0-9\\.]/, false)) {\n            var floatLiteral = false;\n            // Floats\n            if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) floatLiteral = true;\n            if (stream.match(/^[\\d_]+\\.\\d*/)) floatLiteral = true;\n            if (stream.match(/^\\.\\d+/)) floatLiteral = true;\n            if (floatLiteral) {\n                // Float literals may be \"imaginary\"\n                stream.eat(/J/i);\n                return \"number\";\n            }\n            // Integers\n            var intLiteral = false;\n            // Hex\n            if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n            // Binary\n            if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n            // Octal\n            if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n            // Decimal\n            if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n                // Decimal literals may be \"imaginary\"\n                stream.eat(/J/i);\n                // TODO - Can you have imaginary longs?\n                intLiteral = true;\n            }\n            // Zero by itself with no other piece of number.\n            if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n            if (intLiteral) {\n                // Integer literals may be \"long\"\n                stream.eat(/L/i);\n                return \"number\";\n            }\n        }\n        // Handle Strings\n        if (stream.match(stringPrefixes)) {\n            var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n            if (!isFmtString) {\n                state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n                return state.tokenize(stream, state);\n            } else {\n                state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n                return state.tokenize(stream, state);\n            }\n        }\n        for(var i = 0; i < operators.length; i++)if (stream.match(operators[i])) return \"operator\";\n        if (stream.match(delimiters)) return \"punctuation\";\n        if (state.lastToken == \".\" && stream.match(identifiers)) return \"property\";\n        if (stream.match(keywords) || stream.match($cc176a2ad4060fe7$var$wordOperators)) return \"keyword\";\n        if (stream.match(builtins)) return \"builtin\";\n        if (stream.match(/^(self|cls)\\b/)) return \"self\";\n        if (stream.match(identifiers)) {\n            if (state.lastToken == \"def\" || state.lastToken == \"class\") return \"def\";\n            return \"variable\";\n        }\n        // Handle non-detected items\n        stream.next();\n        return inFormat ? null : ERRORCLASS;\n    }\n    function formatStringFactory(delimiter, tokenOuter) {\n        while(\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)delimiter = delimiter.substr(1);\n        var singleline = delimiter.length == 1;\n        var OUTCLASS = \"string\";\n        function tokenNestedExpr(depth) {\n            return function(stream, state) {\n                var inner = tokenBaseInner(stream, state, true);\n                if (inner == \"punctuation\") {\n                    if (stream.current() == \"{\") state.tokenize = tokenNestedExpr(depth + 1);\n                    else if (stream.current() == \"}\") {\n                        if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1);\n                        else state.tokenize = tokenString;\n                    }\n                }\n                return inner;\n            };\n        }\n        function tokenString(stream, state) {\n            while(!stream.eol()){\n                stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n                if (stream.eat(\"\\\\\")) {\n                    stream.next();\n                    if (singleline && stream.eol()) return OUTCLASS;\n                } else if (stream.match(delimiter)) {\n                    state.tokenize = tokenOuter;\n                    return OUTCLASS;\n                } else if (stream.match('{{')) // ignore {{ in f-str\n                return OUTCLASS;\n                else if (stream.match('{', false)) {\n                    // switch to nested mode\n                    state.tokenize = tokenNestedExpr(0);\n                    if (stream.current()) return OUTCLASS;\n                    else return state.tokenize(stream, state);\n                } else if (stream.match('}}')) return OUTCLASS;\n                else if (stream.match('}')) // single } in f-string is an error\n                return ERRORCLASS;\n                else stream.eat(/['\"]/);\n            }\n            if (singleline) {\n                if (parserConf.singleLineStringErrors) return ERRORCLASS;\n                else state.tokenize = tokenOuter;\n            }\n            return OUTCLASS;\n        }\n        tokenString.isString = true;\n        return tokenString;\n    }\n    function tokenStringFactory(delimiter, tokenOuter) {\n        while(\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)delimiter = delimiter.substr(1);\n        var singleline = delimiter.length == 1;\n        var OUTCLASS = \"string\";\n        function tokenString(stream, state) {\n            while(!stream.eol()){\n                stream.eatWhile(/[^'\"\\\\]/);\n                if (stream.eat(\"\\\\\")) {\n                    stream.next();\n                    if (singleline && stream.eol()) return OUTCLASS;\n                } else if (stream.match(delimiter)) {\n                    state.tokenize = tokenOuter;\n                    return OUTCLASS;\n                } else stream.eat(/['\"]/);\n            }\n            if (singleline) {\n                if (parserConf.singleLineStringErrors) return ERRORCLASS;\n                else state.tokenize = tokenOuter;\n            }\n            return OUTCLASS;\n        }\n        tokenString.isString = true;\n        return tokenString;\n    }\n    function pushPyScope(stream, state) {\n        while($cc176a2ad4060fe7$var$top(state).type != \"py\")state.scopes.pop();\n        state.scopes.push({\n            offset: $cc176a2ad4060fe7$var$top(state).offset + stream.indentUnit,\n            type: \"py\",\n            align: null\n        });\n    }\n    function pushBracketScope(stream, state, type) {\n        var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1;\n        state.scopes.push({\n            offset: state.indent + (hangingIndent || stream.indentUnit),\n            type: type,\n            align: align\n        });\n    }\n    function dedent(stream, state) {\n        var indented = stream.indentation();\n        while(state.scopes.length > 1 && $cc176a2ad4060fe7$var$top(state).offset > indented){\n            if ($cc176a2ad4060fe7$var$top(state).type != \"py\") return true;\n            state.scopes.pop();\n        }\n        return $cc176a2ad4060fe7$var$top(state).offset != indented;\n    }\n    function tokenLexer(stream, state) {\n        if (stream.sol()) {\n            state.beginningOfLine = true;\n            state.dedent = false;\n        }\n        var style = state.tokenize(stream, state);\n        var current = stream.current();\n        // Handle decorators\n        if (state.beginningOfLine && current == \"@\") return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n        if (/\\S/.test(current)) state.beginningOfLine = false;\n        if ((style == \"variable\" || style == \"builtin\") && state.lastToken == \"meta\") style = \"meta\";\n        // Handle scope changes.\n        if (current == \"pass\" || current == \"return\") state.dedent = true;\n        if (current == \"lambda\") state.lambda = true;\n        if (current == \":\" && !state.lambda && $cc176a2ad4060fe7$var$top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false)) pushPyScope(stream, state);\n        if (current.length == 1 && !/string|comment/.test(style)) {\n            var delimiter_index = \"[({\".indexOf(current);\n            if (delimiter_index != -1) pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n            delimiter_index = \"])}\".indexOf(current);\n            if (delimiter_index != -1) {\n                if ($cc176a2ad4060fe7$var$top(state).type == current) state.indent = state.scopes.pop().offset - (hangingIndent || stream.indentUnit);\n                else return ERRORCLASS;\n            }\n        }\n        if (state.dedent && stream.eol() && $cc176a2ad4060fe7$var$top(state).type == \"py\" && state.scopes.length > 1) state.scopes.pop();\n        return style;\n    }\n    return {\n        name: \"python\",\n        startState: function() {\n            return {\n                tokenize: tokenBase,\n                scopes: [\n                    {\n                        offset: 0,\n                        type: \"py\",\n                        align: null\n                    }\n                ],\n                indent: 0,\n                lastToken: null,\n                lambda: false,\n                dedent: 0\n            };\n        },\n        token: function(stream, state) {\n            var addErr = state.errorToken;\n            if (addErr) state.errorToken = false;\n            var style = tokenLexer(stream, state);\n            if (style && style != \"comment\") state.lastToken = style == \"keyword\" || style == \"punctuation\" ? stream.current() : style;\n            if (style == \"punctuation\") style = null;\n            if (stream.eol() && state.lambda) state.lambda = false;\n            return addErr ? ERRORCLASS : style;\n        },\n        indent: function(state, textAfter, cx) {\n            if (state.tokenize != tokenBase) return state.tokenize.isString ? null : 0;\n            var scope = $cc176a2ad4060fe7$var$top(state);\n            var closing = scope.type == textAfter.charAt(0) || scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter);\n            if (scope.align != null) return scope.align - (closing ? 1 : 0);\n            else return scope.offset - (closing ? hangingIndent || cx.unit : 0);\n        },\n        languageData: {\n            autocomplete: $cc176a2ad4060fe7$var$commonKeywords.concat($cc176a2ad4060fe7$var$commonBuiltins).concat([\n                \"exec\",\n                \"print\"\n            ]),\n            indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n            commentTokens: {\n                line: \"#\"\n            },\n            closeBrackets: {\n                brackets: [\n                    \"(\",\n                    \"[\",\n                    \"{\",\n                    \"'\",\n                    '\"',\n                    \"'''\",\n                    '\"\"\"'\n                ]\n            }\n        }\n    };\n}\nvar $cc176a2ad4060fe7$var$words = function(str) {\n    return str.split(\" \");\n};\nconst $cc176a2ad4060fe7$export$3ccdad7705c71630 = $cc176a2ad4060fe7$export$ac69049de4df6700({});\nconst $cc176a2ad4060fe7$export$dac0ef537f5eb913 = $cc176a2ad4060fe7$export$ac69049de4df6700({\n    extra_keywords: $cc176a2ad4060fe7$var$words(\"by cdef cimport cpdef ctypedef enum except extern gil include nogil property public readonly struct union DEF IF ELIF ELSE\")\n});\n\n});\n\n\n//# sourceMappingURL=python.1dca2a18.js.map\n","function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\nvar commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                      \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                      \"for\", \"from\", \"global\", \"if\", \"import\",\n                      \"lambda\", \"pass\", \"raise\", \"return\",\n                      \"try\", \"while\", \"with\", \"yield\", \"in\", \"False\", \"True\"];\nvar commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                      \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                      \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                      \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                      \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                      \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                      \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                      \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                      \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                      \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                      \"Ellipsis\", \"__debug__\"];\n\nfunction top(state) {\n  return state.scopes[state.scopes.length - 1];\n}\n\nexport function mkPython(parserConf) {\n  var ERRORCLASS = \"error\";\n\n  var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n  //               (Backwards-compatibility with old, cumbersome config system)\n  var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                   parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n  for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n  var hangingIndent = parserConf.hangingIndent;\n\n  var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n  if (parserConf.extra_keywords != undefined)\n    myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n  if (parserConf.extra_builtins != undefined)\n    myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n  var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n  if (py3) {\n    // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n    var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n    myKeywords = myKeywords.concat([\"nonlocal\", \"None\", \"aiter\", \"anext\", \"async\", \"await\", \"breakpoint\", \"match\", \"case\"]);\n    myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n    var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n  } else {\n    var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n    myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n    myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                    \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                    \"unichr\", \"unicode\", \"xrange\", \"None\"]);\n    var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n  }\n  var keywords = wordRegexp(myKeywords);\n  var builtins = wordRegexp(myBuiltins);\n\n  // tokenizers\n  function tokenBase(stream, state) {\n    var sol = stream.sol() && state.lastToken != \"\\\\\"\n    if (sol) state.indent = stream.indentation()\n    // Handle scope changes\n    if (sol && top(state).type == \"py\") {\n      var scopeOffset = top(state).offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset)\n          pushPyScope(stream, state);\n        else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n          state.errorToken = true;\n        return null;\n      } else {\n        var style = tokenBaseInner(stream, state);\n        if (scopeOffset > 0 && dedent(stream, state))\n          style += \" \" + ERRORCLASS;\n        return style;\n      }\n    }\n    return tokenBaseInner(stream, state);\n  }\n\n  function tokenBaseInner(stream, state, inFormat) {\n    if (stream.eatSpace()) return null;\n\n    // Handle Comments\n    if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n\n    // Handle Number Literals\n    if (stream.match(/^[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n      if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n      if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n      if (floatLiteral) {\n        // Float literals may be \"imaginary\"\n        stream.eat(/J/i);\n        return \"number\";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n      // Binary\n      if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n      // Octal\n      if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n      // Decimal\n      if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n        // Decimal literals may be \"imaginary\"\n        stream.eat(/J/i);\n        // TODO - Can you have imaginary longs?\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n      if (intLiteral) {\n        // Integer literals may be \"long\"\n        stream.eat(/L/i);\n        return \"number\";\n      }\n    }\n\n    // Handle Strings\n    if (stream.match(stringPrefixes)) {\n      var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n      if (!isFmtString) {\n        state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n        return state.tokenize(stream, state);\n      } else {\n        state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n        return state.tokenize(stream, state);\n      }\n    }\n\n    for (var i = 0; i < operators.length; i++)\n      if (stream.match(operators[i])) return \"operator\"\n\n    if (stream.match(delimiters)) return \"punctuation\";\n\n    if (state.lastToken == \".\" && stream.match(identifiers))\n      return \"property\";\n\n    if (stream.match(keywords) || stream.match(wordOperators))\n      return \"keyword\";\n\n    if (stream.match(builtins))\n      return \"builtin\";\n\n    if (stream.match(/^(self|cls)\\b/))\n      return \"self\";\n\n    if (stream.match(identifiers)) {\n      if (state.lastToken == \"def\" || state.lastToken == \"class\")\n        return \"def\";\n      return \"variable\";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return inFormat ? null :ERRORCLASS;\n  }\n\n  function formatStringFactory(delimiter, tokenOuter) {\n    while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n      delimiter = delimiter.substr(1);\n\n    var singleline = delimiter.length == 1;\n    var OUTCLASS = \"string\";\n\n    function tokenNestedExpr(depth) {\n      return function(stream, state) {\n        var inner = tokenBaseInner(stream, state, true)\n        if (inner == \"punctuation\") {\n          if (stream.current() == \"{\") {\n            state.tokenize = tokenNestedExpr(depth + 1)\n          } else if (stream.current() == \"}\") {\n            if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n            else state.tokenize = tokenString\n          }\n        }\n        return inner\n      }\n    }\n\n    function tokenString(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol())\n            return OUTCLASS;\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenOuter;\n          return OUTCLASS;\n        } else if (stream.match('{{')) {\n          // ignore {{ in f-str\n          return OUTCLASS;\n        } else if (stream.match('{', false)) {\n          // switch to nested mode\n          state.tokenize = tokenNestedExpr(0)\n          if (stream.current()) return OUTCLASS;\n          else return state.tokenize(stream, state)\n        } else if (stream.match('}}')) {\n          return OUTCLASS;\n        } else if (stream.match('}')) {\n          // single } in f-string is an error\n          return ERRORCLASS;\n        } else {\n          stream.eat(/['\"]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors)\n          return ERRORCLASS;\n        else\n          state.tokenize = tokenOuter;\n      }\n      return OUTCLASS;\n    }\n    tokenString.isString = true;\n    return tokenString;\n  }\n\n  function tokenStringFactory(delimiter, tokenOuter) {\n    while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n      delimiter = delimiter.substr(1);\n\n    var singleline = delimiter.length == 1;\n    var OUTCLASS = \"string\";\n\n    function tokenString(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol())\n            return OUTCLASS;\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenOuter;\n          return OUTCLASS;\n        } else {\n          stream.eat(/['\"]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors)\n          return ERRORCLASS;\n        else\n          state.tokenize = tokenOuter;\n      }\n      return OUTCLASS;\n    }\n    tokenString.isString = true;\n    return tokenString;\n  }\n\n  function pushPyScope(stream, state) {\n    while (top(state).type != \"py\") state.scopes.pop()\n    state.scopes.push({offset: top(state).offset + stream.indentUnit,\n                       type: \"py\",\n                       align: null})\n  }\n\n  function pushBracketScope(stream, state, type) {\n    var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1\n    state.scopes.push({offset: state.indent + (hangingIndent || stream.indentUnit),\n                       type: type,\n                       align: align})\n  }\n\n  function dedent(stream, state) {\n    var indented = stream.indentation();\n    while (state.scopes.length > 1 && top(state).offset > indented) {\n      if (top(state).type != \"py\") return true;\n      state.scopes.pop();\n    }\n    return top(state).offset != indented;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) {\n      state.beginningOfLine = true;\n      state.dedent = false;\n    }\n\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle decorators\n    if (state.beginningOfLine && current == \"@\")\n      return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n    if (/\\S/.test(current)) state.beginningOfLine = false;\n\n    if ((style == \"variable\" || style == \"builtin\")\n        && state.lastToken == \"meta\")\n      style = \"meta\";\n\n    // Handle scope changes.\n    if (current == \"pass\" || current == \"return\")\n      state.dedent = true;\n\n    if (current == \"lambda\") state.lambda = true;\n    if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false))\n      pushPyScope(stream, state);\n\n    if (current.length == 1 && !/string|comment/.test(style)) {\n      var delimiter_index = \"[({\".indexOf(current);\n      if (delimiter_index != -1)\n        pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n      delimiter_index = \"])}\".indexOf(current);\n      if (delimiter_index != -1) {\n        if (top(state).type == current) state.indent = state.scopes.pop().offset - (hangingIndent || stream.indentUnit)\n        else return ERRORCLASS;\n      }\n    }\n    if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1)\n      state.scopes.pop();\n\n    return style;\n  }\n\n  return {\n    name: \"python\",\n\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        scopes: [{offset: 0, type: \"py\", align: null}],\n        indent: 0,\n        lastToken: null,\n        lambda: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var addErr = state.errorToken;\n      if (addErr) state.errorToken = false;\n      var style = tokenLexer(stream, state);\n\n      if (style && style != \"comment\")\n        state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n      if (style == \"punctuation\") style = null;\n\n      if (stream.eol() && state.lambda)\n        state.lambda = false;\n      return addErr ? ERRORCLASS : style;\n    },\n\n    indent: function(state, textAfter, cx) {\n      if (state.tokenize != tokenBase)\n        return state.tokenize.isString ? null : 0;\n\n      var scope = top(state)\n      var closing = scope.type == textAfter.charAt(0) ||\n          scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)\n      if (scope.align != null)\n        return scope.align - (closing ? 1 : 0)\n      else\n        return scope.offset - (closing ? hangingIndent || cx.unit : 0)\n    },\n\n    languageData: {\n      autocomplete: commonKeywords.concat(commonBuiltins).concat([\"exec\", \"print\"]),\n      indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      commentTokens: {line: \"#\"},\n      closeBrackets: {brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"']}\n    }\n  };\n};\n\nvar words = function(str) { return str.split(\" \"); };\n\nexport const python = mkPython({})\n\nexport const cython = mkPython({\n  extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                        \"extern gil include nogil property public \"+\n                        \"readonly struct union DEF IF ELIF ELSE\")\n})\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","$cc176a2ad4060fe7$var$wordRegexp","words","RegExp","join","Object","defineProperty","get","$cc176a2ad4060fe7$export$dac0ef537f5eb913","set","s","enumerable","configurable","$cc176a2ad4060fe7$var$wordOperators","$cc176a2ad4060fe7$var$commonKeywords","$cc176a2ad4060fe7$var$commonBuiltins","$cc176a2ad4060fe7$var$top","state","scopes","length","$cc176a2ad4060fe7$export$ac69049de4df6700","parserConf","ERRORCLASS","delimiters","singleDelimiters","operators","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","i","splice","hangingIndent","myKeywords","myBuiltins","undefined","extra_keywords","concat","extra_builtins","py3","version","Number","identifiers","stringPrefixes","keywords","builtins","tokenBase","stream","sol","lastToken","indent","indentation","type","scopeOffset","offset","eatSpace","lineOffset","pushPyScope","dedent","peek","errorToken","style","tokenBaseInner","inFormat","match","floatLiteral","eat","intLiteral","current","toLowerCase","indexOf","tokenize","tokenStringFactory","delimiter","tokenOuter","charAt","substr","singleline","OUTCLASS","tokenString","eol","eatWhile","next","singleLineStringErrors","isString","formatStringFactory","tokenNestedExpr","depth","inner","pop","push","indentUnit","align","indented","name","startState","lambda","token","addErr","tokenLexer","beginningOfLine","test","delimiter_index","slice","column","textAfter","cx","scope","closing","unit","languageData","autocomplete","indentOnInput","commentTokens","line","closeBrackets","brackets","str","split"],"version":3,"file":"python.1dca2a18.js.map"}