{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/crystal.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"b7xwX\", function(module, exports) {\n\n$parcel$export(module.exports, \"crystal\", () => $818a5ba4da073ea5$export$57588ade2383212b);\nfunction $818a5ba4da073ea5$var$wordRegExp(words, end) {\n    return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\nfunction $818a5ba4da073ea5$var$chain(tokenize, stream, state) {\n    state.tokenize.push(tokenize);\n    return tokenize(stream, state);\n}\nvar $818a5ba4da073ea5$var$operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar $818a5ba4da073ea5$var$conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar $818a5ba4da073ea5$var$indexingOperators = /^(?:\\[\\][?=]?)/;\nvar $818a5ba4da073ea5$var$anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar $818a5ba4da073ea5$var$idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar $818a5ba4da073ea5$var$types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar $818a5ba4da073ea5$var$keywords = $818a5ba4da073ea5$var$wordRegExp([\n    \"abstract\",\n    \"alias\",\n    \"as\",\n    \"asm\",\n    \"begin\",\n    \"break\",\n    \"case\",\n    \"class\",\n    \"def\",\n    \"do\",\n    \"else\",\n    \"elsif\",\n    \"end\",\n    \"ensure\",\n    \"enum\",\n    \"extend\",\n    \"for\",\n    \"fun\",\n    \"if\",\n    \"include\",\n    \"instance_sizeof\",\n    \"lib\",\n    \"macro\",\n    \"module\",\n    \"next\",\n    \"of\",\n    \"out\",\n    \"pointerof\",\n    \"private\",\n    \"protected\",\n    \"rescue\",\n    \"return\",\n    \"require\",\n    \"select\",\n    \"sizeof\",\n    \"struct\",\n    \"super\",\n    \"then\",\n    \"type\",\n    \"typeof\",\n    \"uninitialized\",\n    \"union\",\n    \"unless\",\n    \"until\",\n    \"when\",\n    \"while\",\n    \"with\",\n    \"yield\",\n    \"__DIR__\",\n    \"__END_LINE__\",\n    \"__FILE__\",\n    \"__LINE__\"\n]);\nvar $818a5ba4da073ea5$var$atomWords = $818a5ba4da073ea5$var$wordRegExp([\n    \"true\",\n    \"false\",\n    \"nil\",\n    \"self\"\n]);\nvar $818a5ba4da073ea5$var$indentKeywordsArray = [\n    \"def\",\n    \"fun\",\n    \"macro\",\n    \"class\",\n    \"module\",\n    \"struct\",\n    \"lib\",\n    \"enum\",\n    \"union\",\n    \"do\",\n    \"for\"\n];\nvar $818a5ba4da073ea5$var$indentKeywords = $818a5ba4da073ea5$var$wordRegExp($818a5ba4da073ea5$var$indentKeywordsArray);\nvar $818a5ba4da073ea5$var$indentExpressionKeywordsArray = [\n    \"if\",\n    \"unless\",\n    \"case\",\n    \"while\",\n    \"until\",\n    \"begin\",\n    \"then\"\n];\nvar $818a5ba4da073ea5$var$indentExpressionKeywords = $818a5ba4da073ea5$var$wordRegExp($818a5ba4da073ea5$var$indentExpressionKeywordsArray);\nvar $818a5ba4da073ea5$var$dedentKeywordsArray = [\n    \"end\",\n    \"else\",\n    \"elsif\",\n    \"rescue\",\n    \"ensure\"\n];\nvar $818a5ba4da073ea5$var$dedentKeywords = $818a5ba4da073ea5$var$wordRegExp($818a5ba4da073ea5$var$dedentKeywordsArray);\nvar $818a5ba4da073ea5$var$dedentPunctualsArray = [\n    \"\\\\)\",\n    \"\\\\}\",\n    \"\\\\]\"\n];\nvar $818a5ba4da073ea5$var$dedentPunctuals = new RegExp(\"^(?:\" + $818a5ba4da073ea5$var$dedentPunctualsArray.join(\"|\") + \")$\");\nvar $818a5ba4da073ea5$var$nextTokenizer = {\n    \"def\": $818a5ba4da073ea5$var$tokenFollowIdent,\n    \"fun\": $818a5ba4da073ea5$var$tokenFollowIdent,\n    \"macro\": $818a5ba4da073ea5$var$tokenMacroDef,\n    \"class\": $818a5ba4da073ea5$var$tokenFollowType,\n    \"module\": $818a5ba4da073ea5$var$tokenFollowType,\n    \"struct\": $818a5ba4da073ea5$var$tokenFollowType,\n    \"lib\": $818a5ba4da073ea5$var$tokenFollowType,\n    \"enum\": $818a5ba4da073ea5$var$tokenFollowType,\n    \"union\": $818a5ba4da073ea5$var$tokenFollowType\n};\nvar $818a5ba4da073ea5$var$matching = {\n    \"[\": \"]\",\n    \"{\": \"}\",\n    \"(\": \")\",\n    \"<\": \">\"\n};\nfunction $818a5ba4da073ea5$var$tokenBase(stream, state) {\n    if (stream.eatSpace()) return null;\n    // Macros\n    if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenMacro(\"%\", \"%\"), stream, state);\n    if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenMacro(\"{\", \"}\"), stream, state);\n    // Comments\n    if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n    }\n    // Variables and keywords\n    var matched;\n    if (stream.match($818a5ba4da073ea5$var$idents)) {\n        stream.eat(/[?!]/);\n        matched = stream.current();\n        if (stream.eat(\":\")) return \"atom\";\n        else if (state.lastToken == \".\") return \"property\";\n        else if ($818a5ba4da073ea5$var$keywords.test(matched)) {\n            if ($818a5ba4da073ea5$var$indentKeywords.test(matched)) {\n                if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n                    state.blocks.push(matched);\n                    state.currentIndent += 1;\n                }\n            } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && $818a5ba4da073ea5$var$indentExpressionKeywords.test(matched)) {\n                state.blocks.push(matched);\n                state.currentIndent += 1;\n            } else if (matched == \"end\") {\n                state.blocks.pop();\n                state.currentIndent -= 1;\n            }\n            if ($818a5ba4da073ea5$var$nextTokenizer.hasOwnProperty(matched)) state.tokenize.push($818a5ba4da073ea5$var$nextTokenizer[matched]);\n            return \"keyword\";\n        } else if ($818a5ba4da073ea5$var$atomWords.test(matched)) return \"atom\";\n        return \"variable\";\n    }\n    // Class variables and instance variables\n    // or attributes\n    if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        stream.eat(\"@\");\n        stream.match($818a5ba4da073ea5$var$idents) || stream.match($818a5ba4da073ea5$var$types);\n        return \"propertyName\";\n    }\n    // Constants and types\n    if (stream.match($818a5ba4da073ea5$var$types)) return \"tag\";\n    // Symbols or ':' operator\n    if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        else if (stream.match($818a5ba4da073ea5$var$idents) || stream.match($818a5ba4da073ea5$var$types) || stream.match($818a5ba4da073ea5$var$operators) || stream.match($818a5ba4da073ea5$var$conditionalOperators) || stream.match($818a5ba4da073ea5$var$indexingOperators)) return \"atom\";\n        stream.eat(\":\");\n        return \"operator\";\n    }\n    // Strings\n    if (stream.eat(\"\\\"\")) return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenQuote(\"\\\"\", \"string\", true), stream, state);\n    // Strings or regexps or macro variables or '%' operator\n    if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n        if (stream.match(\"%r\")) {\n            // Regexps\n            style = \"string.special\";\n            delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n            embed = false;\n            delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n            embed = false;\n            delim = stream.next();\n        } else {\n            if (delim = stream.match(/^%([^\\w\\s=])/)) delim = delim[1];\n            else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) // Macro variables\n            return \"meta\";\n            else if (stream.eat('%')) // '%' operator\n            return \"operator\";\n        }\n        if ($818a5ba4da073ea5$var$matching.hasOwnProperty(delim)) delim = $818a5ba4da073ea5$var$matching[delim];\n        return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenQuote(delim, style, embed), stream, state);\n    }\n    // Here Docs\n    if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenHereDoc(matched[2], !matched[1]), stream, state);\n    // Characters\n    if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n    }\n    // Numbers\n    if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) stream.match(/^[0-9a-fA-F_]+/);\n        else if (stream.eat(\"o\")) stream.match(/^[0-7_]+/);\n        else if (stream.eat(\"b\")) stream.match(/^[01_]+/);\n        return \"number\";\n    }\n    if (stream.eat(/^\\d/)) {\n        stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n    }\n    // Operators\n    if (stream.match($818a5ba4da073ea5$var$operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n        return \"operator\";\n    }\n    if (stream.match($818a5ba4da073ea5$var$conditionalOperators) || stream.match($818a5ba4da073ea5$var$anotherOperators)) return \"operator\";\n    // Parens and braces\n    if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return $818a5ba4da073ea5$var$chain($818a5ba4da073ea5$var$tokenNest(matched, $818a5ba4da073ea5$var$matching[matched], null), stream, state);\n    }\n    // Escapes\n    if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n    }\n    stream.next();\n    return null;\n}\nfunction $818a5ba4da073ea5$var$tokenNest(begin, end, style, started) {\n    return function(stream, state) {\n        if (!started && stream.match(begin)) {\n            state.tokenize[state.tokenize.length - 1] = $818a5ba4da073ea5$var$tokenNest(begin, end, style, true);\n            state.currentIndent += 1;\n            return style;\n        }\n        var nextStyle = $818a5ba4da073ea5$var$tokenBase(stream, state);\n        if (stream.current() === end) {\n            state.tokenize.pop();\n            state.currentIndent -= 1;\n            nextStyle = style;\n        }\n        return nextStyle;\n    };\n}\nfunction $818a5ba4da073ea5$var$tokenMacro(begin, end, started) {\n    return function(stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n            state.currentIndent += 1;\n            state.tokenize[state.tokenize.length - 1] = $818a5ba4da073ea5$var$tokenMacro(begin, end, true);\n            return \"meta\";\n        }\n        if (stream.match(end + \"}\")) {\n            state.currentIndent -= 1;\n            state.tokenize.pop();\n            return \"meta\";\n        }\n        return $818a5ba4da073ea5$var$tokenBase(stream, state);\n    };\n}\nfunction $818a5ba4da073ea5$var$tokenMacroDef(stream, state) {\n    if (stream.eatSpace()) return null;\n    var matched;\n    if (matched = stream.match($818a5ba4da073ea5$var$idents)) {\n        if (matched == \"def\") return \"keyword\";\n        stream.eat(/[?!]/);\n    }\n    state.tokenize.pop();\n    return \"def\";\n}\nfunction $818a5ba4da073ea5$var$tokenFollowIdent(stream, state) {\n    if (stream.eatSpace()) return null;\n    if (stream.match($818a5ba4da073ea5$var$idents)) stream.eat(/[!?]/);\n    else stream.match($818a5ba4da073ea5$var$operators) || stream.match($818a5ba4da073ea5$var$conditionalOperators) || stream.match($818a5ba4da073ea5$var$indexingOperators);\n    state.tokenize.pop();\n    return \"def\";\n}\nfunction $818a5ba4da073ea5$var$tokenFollowType(stream, state) {\n    if (stream.eatSpace()) return null;\n    stream.match($818a5ba4da073ea5$var$types);\n    state.tokenize.pop();\n    return \"def\";\n}\nfunction $818a5ba4da073ea5$var$tokenQuote(end, style, embed) {\n    return function(stream, state) {\n        var escaped = false;\n        while(stream.peek())if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n                state.tokenize.push($818a5ba4da073ea5$var$tokenMacro(\"%\", \"%\"));\n                return style;\n            }\n            if (stream.match(\"{{\", false)) {\n                state.tokenize.push($818a5ba4da073ea5$var$tokenMacro(\"{\", \"}\"));\n                return style;\n            }\n            if (embed && stream.match(\"#{\", false)) {\n                state.tokenize.push($818a5ba4da073ea5$var$tokenNest(\"#{\", \"}\", \"meta\"));\n                return style;\n            }\n            var ch = stream.next();\n            if (ch == end) {\n                state.tokenize.pop();\n                return style;\n            }\n            escaped = embed && ch == \"\\\\\";\n        } else {\n            stream.next();\n            escaped = false;\n        }\n        return style;\n    };\n}\nfunction $818a5ba4da073ea5$var$tokenHereDoc(phrase, embed) {\n    return function(stream, state) {\n        if (stream.sol()) {\n            stream.eatSpace();\n            if (stream.match(phrase)) {\n                state.tokenize.pop();\n                return \"string\";\n            }\n        }\n        var escaped = false;\n        while(stream.peek())if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n                state.tokenize.push($818a5ba4da073ea5$var$tokenMacro(\"%\", \"%\"));\n                return \"string\";\n            }\n            if (stream.match(\"{{\", false)) {\n                state.tokenize.push($818a5ba4da073ea5$var$tokenMacro(\"{\", \"}\"));\n                return \"string\";\n            }\n            if (embed && stream.match(\"#{\", false)) {\n                state.tokenize.push($818a5ba4da073ea5$var$tokenNest(\"#{\", \"}\", \"meta\"));\n                return \"string\";\n            }\n            escaped = stream.next() == \"\\\\\" && embed;\n        } else {\n            stream.next();\n            escaped = false;\n        }\n        return \"string\";\n    };\n}\nconst $818a5ba4da073ea5$export$57588ade2383212b = {\n    name: \"crystal\",\n    startState: function() {\n        return {\n            tokenize: [\n                $818a5ba4da073ea5$var$tokenBase\n            ],\n            currentIndent: 0,\n            lastToken: null,\n            lastStyle: null,\n            blocks: []\n        };\n    },\n    token: function(stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n        if (style && style != \"comment\") {\n            state.lastToken = token;\n            state.lastStyle = style;\n        }\n        return style;\n    },\n    indent: function(state, textAfter, cx) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n        if ($818a5ba4da073ea5$var$dedentKeywords.test(textAfter) || $818a5ba4da073ea5$var$dedentPunctuals.test(textAfter)) return cx.unit * (state.currentIndent - 1);\n        return cx.unit * state.currentIndent;\n    },\n    languageData: {\n        indentOnInput: $818a5ba4da073ea5$var$wordRegExp($818a5ba4da073ea5$var$dedentPunctualsArray.concat($818a5ba4da073ea5$var$dedentKeywordsArray), true),\n        commentTokens: {\n            line: \"#\"\n        }\n    }\n};\n\n});\n\n\n//# sourceMappingURL=crystal.39f80006.js.map\n","function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\n  \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n  \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n  \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n  \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n  \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n  \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\n  \"def\", \"fun\", \"macro\",\n  \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n  \"do\", \"for\"\n];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n};\nvar matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Macros\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  }\n\n  // Comments\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Variables and keywords\n  var matched;\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n\n    matched = stream.current();\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  }\n\n  // Class variables and instance variables\n  // or attributes\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  }\n\n  // Constants and types\n  if (stream.match(types)) {\n    return \"tag\";\n  }\n\n  // Symbols or ':' operator\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) ||\n               stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n    stream.eat(\":\");\n    return \"operator\";\n  }\n\n  // Strings\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  }\n\n  // Strings or regexps or macro variables or '%' operator\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if(delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  }\n\n  // Here Docs\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n  }\n\n  // Characters\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  }\n\n  // Numbers\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  }\n\n  // Operators\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  }\n\n  // Parens and braces\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  }\n\n  // Escapes\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace()\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = stream.next() == \"\\\\\" && embed;\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  }\n}\n\nexport const crystal = {\n  name: \"crystal\",\n  startState: function () {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n\n  token: function (stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n\n  indent: function (state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","$818a5ba4da073ea5$var$wordRegExp","words","end","RegExp","join","$818a5ba4da073ea5$var$chain","tokenize","stream","state","push","Object","defineProperty","get","$818a5ba4da073ea5$export$57588ade2383212b","set","s","enumerable","configurable","$818a5ba4da073ea5$var$operators","$818a5ba4da073ea5$var$conditionalOperators","$818a5ba4da073ea5$var$indexingOperators","$818a5ba4da073ea5$var$anotherOperators","$818a5ba4da073ea5$var$idents","$818a5ba4da073ea5$var$types","$818a5ba4da073ea5$var$keywords","$818a5ba4da073ea5$var$atomWords","$818a5ba4da073ea5$var$indentKeywords","$818a5ba4da073ea5$var$indentExpressionKeywords","$818a5ba4da073ea5$var$dedentKeywordsArray","$818a5ba4da073ea5$var$dedentKeywords","$818a5ba4da073ea5$var$dedentPunctualsArray","$818a5ba4da073ea5$var$dedentPunctuals","$818a5ba4da073ea5$var$nextTokenizer","$818a5ba4da073ea5$var$tokenFollowIdent","matched","eatSpace","match","eat","pop","$818a5ba4da073ea5$var$tokenFollowType","$818a5ba4da073ea5$var$matching","$818a5ba4da073ea5$var$tokenBase","lastToken","$818a5ba4da073ea5$var$tokenMacro","peek","skipToEnd","current","test","blocks","indexOf","currentIndent","lastStyle","hasOwnProperty","$818a5ba4da073ea5$var$tokenNest","$818a5ba4da073ea5$var$tokenQuote","phrase","embed","delim","style","next","sol","escaped","begin","started","length","nextStyle","ch","name","startState","token","indent","textAfter","cx","replace","unit","languageData","indentOnInput","concat","commentTokens","line"],"version":3,"file":"crystal.39f80006.js.map"}