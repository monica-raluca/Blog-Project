{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/sieve.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"eMNrP\", function(module, exports) {\n\n$parcel$export(module.exports, \"sieve\", () => $ac3be7b72e6fd6ce$export$b1b34c5f5bc2d0e3);\nfunction $ac3be7b72e6fd6ce$var$words(str) {\n    var obj = {}, words = str.split(\" \");\n    for(var i = 0; i < words.length; ++i)obj[words[i]] = true;\n    return obj;\n}\nvar $ac3be7b72e6fd6ce$var$keywords = $ac3be7b72e6fd6ce$var$words(\"if elsif else stop require\");\nvar $ac3be7b72e6fd6ce$var$atoms = $ac3be7b72e6fd6ce$var$words(\"true false not\");\nfunction $ac3be7b72e6fd6ce$var$tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == \"/\" && stream.eat(\"*\")) {\n        state.tokenize = $ac3be7b72e6fd6ce$var$tokenCComment;\n        return $ac3be7b72e6fd6ce$var$tokenCComment(stream, state);\n    }\n    if (ch === '#') {\n        stream.skipToEnd();\n        return \"comment\";\n    }\n    if (ch == \"\\\"\") {\n        state.tokenize = $ac3be7b72e6fd6ce$var$tokenString(ch);\n        return state.tokenize(stream, state);\n    }\n    if (ch == \"(\") {\n        state._indent.push(\"(\");\n        // add virtual angel wings so that editor behaves...\n        // ...more sane incase of broken brackets\n        state._indent.push(\"{\");\n        return null;\n    }\n    if (ch === \"{\") {\n        state._indent.push(\"{\");\n        return null;\n    }\n    if (ch == \")\") {\n        state._indent.pop();\n        state._indent.pop();\n    }\n    if (ch === \"}\") {\n        state._indent.pop();\n        return null;\n    }\n    if (ch == \",\") return null;\n    if (ch == \";\") return null;\n    if (/[{}\\(\\),;]/.test(ch)) return null;\n    // 1*DIGIT \"K\" / \"M\" / \"G\"\n    if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\d]/);\n        stream.eat(/[KkMmGg]/);\n        return \"number\";\n    }\n    // \":\" (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n    if (ch == \":\") {\n        stream.eatWhile(/[a-zA-Z_]/);\n        stream.eatWhile(/[a-zA-Z0-9_]/);\n        return \"operator\";\n    }\n    stream.eatWhile(/\\w/);\n    var cur = stream.current();\n    // \"text:\" *(SP / HTAB) (hash-comment / CRLF)\n    // *(multiline-literal / multiline-dotstart)\n    // \".\" CRLF\n    if (cur == \"text\" && stream.eat(\":\")) {\n        state.tokenize = $ac3be7b72e6fd6ce$var$tokenMultiLineString;\n        return \"string\";\n    }\n    if ($ac3be7b72e6fd6ce$var$keywords.propertyIsEnumerable(cur)) return \"keyword\";\n    if ($ac3be7b72e6fd6ce$var$atoms.propertyIsEnumerable(cur)) return \"atom\";\n    return null;\n}\nfunction $ac3be7b72e6fd6ce$var$tokenMultiLineString(stream, state) {\n    state._multiLineString = true;\n    // the first line is special it may contain a comment\n    if (!stream.sol()) {\n        stream.eatSpace();\n        if (stream.peek() == \"#\") {\n            stream.skipToEnd();\n            return \"comment\";\n        }\n        stream.skipToEnd();\n        return \"string\";\n    }\n    if (stream.next() == \".\" && stream.eol()) {\n        state._multiLineString = false;\n        state.tokenize = $ac3be7b72e6fd6ce$var$tokenBase;\n    }\n    return \"string\";\n}\nfunction $ac3be7b72e6fd6ce$var$tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while((ch = stream.next()) != null){\n        if (maybeEnd && ch == \"/\") {\n            state.tokenize = $ac3be7b72e6fd6ce$var$tokenBase;\n            break;\n        }\n        maybeEnd = ch == \"*\";\n    }\n    return \"comment\";\n}\nfunction $ac3be7b72e6fd6ce$var$tokenString(quote) {\n    return function(stream, state) {\n        var escaped = false, ch;\n        while((ch = stream.next()) != null){\n            if (ch == quote && !escaped) break;\n            escaped = !escaped && ch == \"\\\\\";\n        }\n        if (!escaped) state.tokenize = $ac3be7b72e6fd6ce$var$tokenBase;\n        return \"string\";\n    };\n}\nconst $ac3be7b72e6fd6ce$export$b1b34c5f5bc2d0e3 = {\n    name: \"sieve\",\n    startState: function(base) {\n        return {\n            tokenize: $ac3be7b72e6fd6ce$var$tokenBase,\n            baseIndent: base || 0,\n            _indent: []\n        };\n    },\n    token: function(stream, state) {\n        if (stream.eatSpace()) return null;\n        return (state.tokenize || $ac3be7b72e6fd6ce$var$tokenBase)(stream, state);\n    },\n    indent: function(state, _textAfter, cx) {\n        var length = state._indent.length;\n        if (_textAfter && _textAfter[0] == \"}\") length--;\n        if (length < 0) length = 0;\n        return length * cx.unit;\n    },\n    languageData: {\n        indentOnInput: /^\\s*\\}$/\n    }\n};\n\n});\n\n\n//# sourceMappingURL=sieve.0b415043.js.map\n","function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = words(\"if elsif else stop require\");\nvar atoms = words(\"true false not\");\n\nfunction tokenBase(stream, state) {\n\n  var ch = stream.next();\n  if (ch == \"/\" && stream.eat(\"*\")) {\n    state.tokenize = tokenCComment;\n    return tokenCComment(stream, state);\n  }\n\n  if (ch === '#') {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (ch == \"\\\"\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  if (ch == \"(\") {\n    state._indent.push(\"(\");\n    // add virtual angel wings so that editor behaves...\n    // ...more sane incase of broken brackets\n    state._indent.push(\"{\");\n    return null;\n  }\n\n  if (ch === \"{\") {\n    state._indent.push(\"{\");\n    return null;\n  }\n\n  if (ch == \")\")  {\n    state._indent.pop();\n    state._indent.pop();\n  }\n\n  if (ch === \"}\") {\n    state._indent.pop();\n    return null;\n  }\n\n  if (ch == \",\")\n    return null;\n\n  if (ch == \";\")\n    return null;\n\n\n  if (/[{}\\(\\),;]/.test(ch))\n    return null;\n\n  // 1*DIGIT \"K\" / \"M\" / \"G\"\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\d]/);\n    stream.eat(/[KkMmGg]/);\n    return \"number\";\n  }\n\n  // \":\" (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n  if (ch == \":\") {\n    stream.eatWhile(/[a-zA-Z_]/);\n    stream.eatWhile(/[a-zA-Z0-9_]/);\n\n    return \"operator\";\n  }\n\n  stream.eatWhile(/\\w/);\n  var cur = stream.current();\n\n  // \"text:\" *(SP / HTAB) (hash-comment / CRLF)\n  // *(multiline-literal / multiline-dotstart)\n  // \".\" CRLF\n  if ((cur == \"text\") && stream.eat(\":\"))\n  {\n    state.tokenize = tokenMultiLineString;\n    return \"string\";\n  }\n\n  if (keywords.propertyIsEnumerable(cur))\n    return \"keyword\";\n\n  if (atoms.propertyIsEnumerable(cur))\n    return \"atom\";\n\n  return null;\n}\n\nfunction tokenMultiLineString(stream, state)\n{\n  state._multiLineString = true;\n  // the first line is special it may contain a comment\n  if (!stream.sol()) {\n    stream.eatSpace();\n\n    if (stream.peek() == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    stream.skipToEnd();\n    return \"string\";\n  }\n\n  if ((stream.next() == \".\")  && (stream.eol()))\n  {\n    state._multiLineString = false;\n    state.tokenize = tokenBase;\n  }\n\n  return \"string\";\n}\n\nfunction tokenCComment(stream, state) {\n  var maybeEnd = false, ch;\n  while ((ch = stream.next()) != null) {\n    if (maybeEnd && ch == \"/\") {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped)\n        break;\n      escaped = !escaped && ch == \"\\\\\";\n    }\n    if (!escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nexport const sieve = {\n  name: \"sieve\",\n  startState: function(base) {\n    return {tokenize: tokenBase,\n            baseIndent: base || 0,\n            _indent: []};\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace())\n      return null;\n\n    return (state.tokenize || tokenBase)(stream, state);\n  },\n\n  indent: function(state, _textAfter, cx) {\n    var length = state._indent.length;\n    if (_textAfter && (_textAfter[0] == \"}\"))\n      length--;\n\n    if (length <0)\n      length = 0;\n\n    return length * cx.unit;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*\\}$/\n  }\n};\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","$ac3be7b72e6fd6ce$var$words","str","obj","words","split","i","length","Object","defineProperty","get","$ac3be7b72e6fd6ce$export$b1b34c5f5bc2d0e3","set","s","enumerable","configurable","$ac3be7b72e6fd6ce$var$keywords","$ac3be7b72e6fd6ce$var$atoms","$ac3be7b72e6fd6ce$var$tokenBase","stream","state","quote","ch","next","eat","tokenize","$ac3be7b72e6fd6ce$var$tokenCComment","skipToEnd","escaped","_indent","push","pop","test","eatWhile","cur","current","$ac3be7b72e6fd6ce$var$tokenMultiLineString","propertyIsEnumerable","_multiLineString","sol","eol","eatSpace","peek","maybeEnd","name","startState","base","baseIndent","token","indent","_textAfter","cx","unit","languageData","indentOnInput"],"version":3,"file":"sieve.0b415043.js.map"}