{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/oz.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5CYNT\", function(module, exports) {\n\n$parcel$export(module.exports, \"oz\", () => $418faab09649a3e3$export$404b7d2fe0f05dfd);\nfunction $418faab09649a3e3$var$wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\nvar $418faab09649a3e3$var$singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\nvar $418faab09649a3e3$var$doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\nvar $418faab09649a3e3$var$tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\nvar $418faab09649a3e3$var$middle = [\n    \"in\",\n    \"then\",\n    \"else\",\n    \"of\",\n    \"elseof\",\n    \"elsecase\",\n    \"elseif\",\n    \"catch\",\n    \"finally\",\n    \"with\",\n    \"require\",\n    \"prepare\",\n    \"import\",\n    \"export\",\n    \"define\",\n    \"do\"\n];\nvar $418faab09649a3e3$var$end = [\n    \"end\"\n];\nvar $418faab09649a3e3$var$atoms = $418faab09649a3e3$var$wordRegexp([\n    \"true\",\n    \"false\",\n    \"nil\",\n    \"unit\"\n]);\nvar $418faab09649a3e3$var$commonKeywords = $418faab09649a3e3$var$wordRegexp([\n    \"andthen\",\n    \"at\",\n    \"attr\",\n    \"declare\",\n    \"feat\",\n    \"from\",\n    \"lex\",\n    \"mod\",\n    \"div\",\n    \"mode\",\n    \"orelse\",\n    \"parser\",\n    \"prod\",\n    \"prop\",\n    \"scanner\",\n    \"self\",\n    \"syn\",\n    \"token\"\n]);\nvar $418faab09649a3e3$var$openingKeywords = $418faab09649a3e3$var$wordRegexp([\n    \"local\",\n    \"proc\",\n    \"fun\",\n    \"case\",\n    \"class\",\n    \"if\",\n    \"cond\",\n    \"or\",\n    \"dis\",\n    \"choice\",\n    \"not\",\n    \"thread\",\n    \"try\",\n    \"raise\",\n    \"lock\",\n    \"for\",\n    \"suchthat\",\n    \"meth\",\n    \"functor\"\n]);\nvar $418faab09649a3e3$var$middleKeywords = $418faab09649a3e3$var$wordRegexp($418faab09649a3e3$var$middle);\nvar $418faab09649a3e3$var$endKeywords = $418faab09649a3e3$var$wordRegexp($418faab09649a3e3$var$end);\n// Tokenizers\nfunction $418faab09649a3e3$var$tokenBase(stream, state) {\n    if (stream.eatSpace()) return null;\n    // Brackets\n    if (stream.match(/[{}]/)) return \"bracket\";\n    // Special [] keyword\n    if (stream.match('[]')) return \"keyword\";\n    // Operators\n    if (stream.match($418faab09649a3e3$var$tripleOperators) || stream.match($418faab09649a3e3$var$doubleOperators)) return \"operator\";\n    // Atoms\n    if (stream.match($418faab09649a3e3$var$atoms)) return 'atom';\n    // Opening keywords\n    var matched = stream.match($418faab09649a3e3$var$openingKeywords);\n    if (matched) {\n        if (!state.doInCurrentLine) state.currentIndent++;\n        else state.doInCurrentLine = false;\n        // Special matching for signatures\n        if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = $418faab09649a3e3$var$tokenFunProc;\n        else if (matched[0] == \"class\") state.tokenize = $418faab09649a3e3$var$tokenClass;\n        else if (matched[0] == \"meth\") state.tokenize = $418faab09649a3e3$var$tokenMeth;\n        return 'keyword';\n    }\n    // Middle and other keywords\n    if (stream.match($418faab09649a3e3$var$middleKeywords) || stream.match($418faab09649a3e3$var$commonKeywords)) return \"keyword\";\n    // End keywords\n    if (stream.match($418faab09649a3e3$var$endKeywords)) {\n        state.currentIndent--;\n        return 'keyword';\n    }\n    // Eat the next char for next comparisons\n    var ch = stream.next();\n    // Strings\n    if (ch == '\"' || ch == \"'\") {\n        state.tokenize = $418faab09649a3e3$var$tokenString(ch);\n        return state.tokenize(stream, state);\n    }\n    // Numbers\n    if (/[~\\d]/.test(ch)) {\n        if (ch == \"~\") {\n            if (!/^[0-9]/.test(stream.peek())) return null;\n            else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        }\n        if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        return null;\n    }\n    // Comments\n    if (ch == \"%\") {\n        stream.skipToEnd();\n        return 'comment';\n    } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n            state.tokenize = $418faab09649a3e3$var$tokenComment;\n            return $418faab09649a3e3$var$tokenComment(stream, state);\n        }\n    }\n    // Single operators\n    if ($418faab09649a3e3$var$singleOperators.test(ch)) return \"operator\";\n    // If nothing match, we skip the entire alphanumerical block\n    stream.eatWhile(/\\w/);\n    return \"variable\";\n}\nfunction $418faab09649a3e3$var$tokenClass(stream, state) {\n    if (stream.eatSpace()) return null;\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = $418faab09649a3e3$var$tokenBase;\n    return \"type\";\n}\nfunction $418faab09649a3e3$var$tokenMeth(stream, state) {\n    if (stream.eatSpace()) return null;\n    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = $418faab09649a3e3$var$tokenBase;\n    return \"def\";\n}\nfunction $418faab09649a3e3$var$tokenFunProc(stream, state) {\n    if (stream.eatSpace()) return null;\n    if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n        state.hasPassedFirstStage = true;\n        return \"bracket\";\n    } else if (state.hasPassedFirstStage) {\n        stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n        state.hasPassedFirstStage = false;\n        state.tokenize = $418faab09649a3e3$var$tokenBase;\n        return \"def\";\n    } else {\n        state.tokenize = $418faab09649a3e3$var$tokenBase;\n        return null;\n    }\n}\nfunction $418faab09649a3e3$var$tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while(ch = stream.next()){\n        if (ch == \"/\" && maybeEnd) {\n            state.tokenize = $418faab09649a3e3$var$tokenBase;\n            break;\n        }\n        maybeEnd = ch == \"*\";\n    }\n    return \"comment\";\n}\nfunction $418faab09649a3e3$var$tokenString(quote) {\n    return function(stream, state) {\n        var escaped = false, next, end = false;\n        while((next = stream.next()) != null){\n            if (next == quote && !escaped) {\n                end = true;\n                break;\n            }\n            escaped = !escaped && next == \"\\\\\";\n        }\n        if (end || !escaped) state.tokenize = $418faab09649a3e3$var$tokenBase;\n        return \"string\";\n    };\n}\nfunction $418faab09649a3e3$var$buildElectricInputRegEx() {\n    // Reindentation should occur on [] or on a match of any of\n    // the block closing keywords, at the end of a line.\n    var allClosings = $418faab09649a3e3$var$middle.concat($418faab09649a3e3$var$end);\n    return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n}\nconst $418faab09649a3e3$export$404b7d2fe0f05dfd = {\n    name: \"oz\",\n    startState: function() {\n        return {\n            tokenize: $418faab09649a3e3$var$tokenBase,\n            currentIndent: 0,\n            doInCurrentLine: false,\n            hasPassedFirstStage: false\n        };\n    },\n    token: function(stream, state) {\n        if (stream.sol()) state.doInCurrentLine = 0;\n        return state.tokenize(stream, state);\n    },\n    indent: function(state, textAfter, cx) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match($418faab09649a3e3$var$endKeywords) || trueText.match($418faab09649a3e3$var$middleKeywords) || trueText.match(/(\\[])/)) return cx.unit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * cx.unit;\n    },\n    languageData: {\n        indentOnInut: $418faab09649a3e3$var$buildElectricInputRegEx(),\n        commentTokens: {\n            line: \"%\",\n            block: {\n                open: \"/*\",\n                close: \"*/\"\n            }\n        }\n    }\n};\n\n});\n\n\n//# sourceMappingURL=oz.76e37ea9.js.map\n","function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\nvar doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\nvar tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n\nvar middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\",\n              \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\nvar end = [\"end\"];\n\nvar atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\nvar commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\",\n                                 \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\nvar openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\",\n                                  \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\nvar middleKeywords = wordRegexp(middle);\nvar endKeywords = wordRegexp(end);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Brackets\n  if(stream.match(/[{}]/)) {\n    return \"bracket\";\n  }\n\n  // Special [] keyword\n  if (stream.match('[]')) {\n    return \"keyword\"\n  }\n\n  // Operators\n  if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n    return \"operator\";\n  }\n\n  // Atoms\n  if(stream.match(atoms)) {\n    return 'atom';\n  }\n\n  // Opening keywords\n  var matched = stream.match(openingKeywords);\n  if (matched) {\n    if (!state.doInCurrentLine)\n      state.currentIndent++;\n    else\n      state.doInCurrentLine = false;\n\n    // Special matching for signatures\n    if(matched[0] == \"proc\" || matched[0] == \"fun\")\n      state.tokenize = tokenFunProc;\n    else if(matched[0] == \"class\")\n      state.tokenize = tokenClass;\n    else if(matched[0] == \"meth\")\n      state.tokenize = tokenMeth;\n\n    return 'keyword';\n  }\n\n  // Middle and other keywords\n  if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n    return \"keyword\"\n  }\n\n  // End keywords\n  if (stream.match(endKeywords)) {\n    state.currentIndent--;\n    return 'keyword';\n  }\n\n  // Eat the next char for next comparisons\n  var ch = stream.next();\n\n  // Strings\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  // Numbers\n  if (/[~\\d]/.test(ch)) {\n    if (ch == \"~\") {\n      if(! /^[0-9]/.test(stream.peek()))\n        return null;\n      else if (( stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n        return \"number\";\n    }\n\n    if ((ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n      return \"number\";\n\n    return null;\n  }\n\n  // Comments\n  if (ch == \"%\") {\n    stream.skipToEnd();\n    return 'comment';\n  }\n  else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n  }\n\n  // Single operators\n  if(singleOperators.test(ch)) {\n    return \"operator\";\n  }\n\n  // If nothing match, we skip the entire alphanumerical block\n  stream.eatWhile(/\\w/);\n\n  return \"variable\";\n}\n\nfunction tokenClass(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"type\"\n}\n\nfunction tokenMeth(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"def\"\n}\n\nfunction tokenFunProc(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if(!state.hasPassedFirstStage && stream.eat(\"{\")) {\n    state.hasPassedFirstStage = true;\n    return \"bracket\";\n  }\n  else if(state.hasPassedFirstStage) {\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n    state.hasPassedFirstStage = false;\n    state.tokenize = tokenBase;\n    return \"def\"\n  }\n  else {\n    state.tokenize = tokenBase;\n    return null;\n  }\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !escaped)\n      state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nfunction buildElectricInputRegEx() {\n  // Reindentation should occur on [] or on a match of any of\n  // the block closing keywords, at the end of a line.\n  var allClosings = middle.concat(end);\n  return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n}\n\nexport const oz = {\n  name: \"oz\",\n\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      currentIndent: 0,\n      doInCurrentLine: false,\n      hasPassedFirstStage: false\n    };\n  },\n\n  token: function (stream, state) {\n    if (stream.sol())\n      state.doInCurrentLine = 0;\n\n    return state.tokenize(stream, state);\n  },\n\n  indent: function (state, textAfter, cx) {\n    var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n\n    if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/))\n      return cx.unit * (state.currentIndent - 1);\n\n    if (state.currentIndent < 0)\n      return 0;\n\n    return state.currentIndent * cx.unit\n  },\n\n  languageData: {\n    indentOnInut: buildElectricInputRegEx(),\n    commentTokens: {line: \"%\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","$418faab09649a3e3$var$wordRegexp","words","RegExp","join","e","Object","defineProperty","get","$418faab09649a3e3$export$404b7d2fe0f05dfd","set","s","enumerable","configurable","$418faab09649a3e3$var$singleOperators","$418faab09649a3e3$var$doubleOperators","$418faab09649a3e3$var$tripleOperators","$418faab09649a3e3$var$middle","$418faab09649a3e3$var$end","$418faab09649a3e3$var$atoms","$418faab09649a3e3$var$commonKeywords","$418faab09649a3e3$var$openingKeywords","$418faab09649a3e3$var$middleKeywords","$418faab09649a3e3$var$endKeywords","$418faab09649a3e3$var$tokenBase","stream","state","eatSpace","match","quote","matched","doInCurrentLine","currentIndent","tokenize","$418faab09649a3e3$var$tokenFunProc","$418faab09649a3e3$var$tokenClass","$418faab09649a3e3$var$tokenMeth","ch","next","escaped","end","test","peek","skipToEnd","eat","$418faab09649a3e3$var$tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","name","startState","token","sol","indent","textAfter","cx","trueText","replace","unit","languageData","indentOnInut","allClosings","concat","commentTokens","line","block","open","close"],"version":3,"file":"oz.76e37ea9.js.map"}