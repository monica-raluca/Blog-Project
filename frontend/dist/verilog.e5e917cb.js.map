{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/verilog.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"gZChN\", function(module, exports) {\n\n$parcel$export(module.exports, \"verilog\", () => $c5f00aa455439ff8$export$ace627bcd07e724c);\nfunction $c5f00aa455439ff8$var$mkVerilog(parserConfig) {\n    var statementIndentUnit = parserConfig.statementIndentUnit, dontAlignCalls = parserConfig.dontAlignCalls, noIndentKeywords = parserConfig.noIndentKeywords || [], multiLineStrings = parserConfig.multiLineStrings, hooks = parserConfig.hooks || {};\n    function words(str) {\n        var obj = {}, words = str.split(\" \");\n        for(var i = 0; i < words.length; ++i)obj[words[i]] = true;\n        return obj;\n    }\n    /**\n   * Keywords from IEEE 1800-2012\n   */ var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import incdir include initial inout input inside instance int integer interconnect interface intersect join join_any join_none large let liblist library local localparam logic longint macromodule matches medium modport module nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n    /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */ var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n    var isBracketChar = /[\\[\\]{}()]/;\n    var unsignedNumber = /\\d[0-9_]*/;\n    var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n    var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n    var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n    var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n    var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n    var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n    var closingBracket = /[)}\\]]/;\n    var curPunc;\n    var curKeyword;\n    // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n    // E.g. \"task\" => \"endtask\"\n    var blockKeywords = words(\"case checker class clocking config function generate interface module package primitive program property specify sequence table task\");\n    // Opening/closing pairs\n    var openClose = {};\n    for(var keyword in blockKeywords)openClose[keyword] = \"end\" + keyword;\n    openClose[\"begin\"] = \"end\";\n    openClose[\"casex\"] = \"endcase\";\n    openClose[\"casez\"] = \"endcase\";\n    openClose[\"do\"] = \"while\";\n    openClose[\"fork\"] = \"join;join_any;join_none\";\n    openClose[\"covergroup\"] = \"endgroup\";\n    for(var i in noIndentKeywords){\n        var keyword = noIndentKeywords[i];\n        if (openClose[keyword]) openClose[keyword] = undefined;\n    }\n    // Keywords which open statements that are ended with a semi-colon\n    var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n    function tokenBase(stream, state) {\n        var ch = stream.peek(), style;\n        if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n        if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n        if (/[,;:\\.]/.test(ch)) {\n            curPunc = stream.next();\n            return null;\n        }\n        if (isBracketChar.test(ch)) {\n            curPunc = stream.next();\n            return \"bracket\";\n        }\n        // Macros (tick-defines)\n        if (ch == '`') {\n            stream.next();\n            if (stream.eatWhile(/[\\w\\$_]/)) return \"def\";\n            else return null;\n        }\n        // System calls\n        if (ch == '$') {\n            stream.next();\n            if (stream.eatWhile(/[\\w\\$_]/)) return \"meta\";\n            else return null;\n        }\n        // Time literals\n        if (ch == '#') {\n            stream.next();\n            stream.eatWhile(/[\\d_.]/);\n            return \"def\";\n        }\n        // Strings\n        if (ch == '\"') {\n            stream.next();\n            state.tokenize = tokenString(ch);\n            return state.tokenize(stream, state);\n        }\n        // Comments\n        if (ch == \"/\") {\n            stream.next();\n            if (stream.eat(\"*\")) {\n                state.tokenize = tokenComment;\n                return tokenComment(stream, state);\n            }\n            if (stream.eat(\"/\")) {\n                stream.skipToEnd();\n                return \"comment\";\n            }\n            stream.backUp(1);\n        }\n        // Numeric literals\n        if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) return \"number\";\n        // Operators\n        if (stream.eatWhile(isOperatorChar)) return \"meta\";\n        // Keywords / plain variables\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n            var cur = stream.current();\n            if (keywords[cur]) {\n                if (openClose[cur]) curPunc = \"newblock\";\n                if (statementKeywords[cur]) curPunc = \"newstatement\";\n                curKeyword = cur;\n                return \"keyword\";\n            }\n            return \"variable\";\n        }\n        stream.next();\n        return null;\n    }\n    function tokenString(quote) {\n        return function(stream, state) {\n            var escaped = false, next, end = false;\n            while((next = stream.next()) != null){\n                if (next == quote && !escaped) {\n                    end = true;\n                    break;\n                }\n                escaped = !escaped && next == \"\\\\\";\n            }\n            if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n            return \"string\";\n        };\n    }\n    function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while(ch = stream.next()){\n            if (ch == \"/\" && maybeEnd) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            maybeEnd = ch == \"*\";\n        }\n        return \"comment\";\n    }\n    function Context(indented, column, type, align, prev) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type;\n        this.align = align;\n        this.prev = prev;\n    }\n    function pushContext(state, col, type) {\n        var indent = state.indented;\n        var c = new Context(indent, col, type, null, state.context);\n        return state.context = c;\n    }\n    function popContext(state) {\n        var t = state.context.type;\n        if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n        return state.context = state.context.prev;\n    }\n    function isClosing(text, contextClosing) {\n        if (text == contextClosing) return true;\n        else {\n            // contextClosing may be multiple keywords separated by ;\n            var closingKeywords = contextClosing.split(\";\");\n            for(var i in closingKeywords){\n                if (text == closingKeywords[i]) return true;\n            }\n            return false;\n        }\n    }\n    function buildElectricInputRegEx() {\n        // Reindentation should occur on any bracket char: {}()[]\n        // or on a match of any of the block closing keywords, at\n        // the end of a line\n        var allClosings = [];\n        for(var i in openClose)if (openClose[i]) {\n            var closings = openClose[i].split(\";\");\n            for(var j in closings)allClosings.push(closings[j]);\n        }\n        var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n        return re;\n    }\n    // Interface\n    return {\n        name: \"verilog\",\n        startState: function(indentUnit) {\n            var state = {\n                tokenize: null,\n                context: new Context(-indentUnit, 0, \"top\", false),\n                indented: 0,\n                startOfLine: true\n            };\n            if (hooks.startState) hooks.startState(state);\n            return state;\n        },\n        token: function(stream, state) {\n            var ctx = state.context;\n            if (stream.sol()) {\n                if (ctx.align == null) ctx.align = false;\n                state.indented = stream.indentation();\n                state.startOfLine = true;\n            }\n            if (hooks.token) {\n                // Call hook, with an optional return value of a style to override verilog styling.\n                var style = hooks.token(stream, state);\n                if (style !== undefined) return style;\n            }\n            if (stream.eatSpace()) return null;\n            curPunc = null;\n            curKeyword = null;\n            var style = (state.tokenize || tokenBase)(stream, state);\n            if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n            if (ctx.align == null) ctx.align = true;\n            if (curPunc == ctx.type) popContext(state);\n            else if (curPunc == \";\" && ctx.type == \"statement\" || ctx.type && isClosing(curKeyword, ctx.type)) {\n                ctx = popContext(state);\n                while(ctx && ctx.type == \"statement\")ctx = popContext(state);\n            } else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n            else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n            else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n            else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") pushContext(state, stream.column(), \"statement\");\n            else if (curPunc == \"newstatement\") pushContext(state, stream.column(), \"statement\");\n            else if (curPunc == \"newblock\") {\n                if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) ;\n                else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") ;\n                else {\n                    var close = openClose[curKeyword];\n                    pushContext(state, stream.column(), close);\n                }\n            }\n            state.startOfLine = false;\n            return style;\n        },\n        indent: function(state, textAfter, cx) {\n            if (state.tokenize != tokenBase && state.tokenize != null) return null;\n            if (hooks.indent) {\n                var fromHook = hooks.indent(state);\n                if (fromHook >= 0) return fromHook;\n            }\n            var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n            if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n            var closing = false;\n            var possibleClosing = textAfter.match(closingBracketOrWord);\n            if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n            if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n            else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n            else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);\n            else return ctx.indented + (closing ? 0 : cx.unit);\n        },\n        languageData: {\n            indentOnInput: buildElectricInputRegEx(),\n            commentTokens: {\n                line: \"//\",\n                block: {\n                    open: \"/*\",\n                    close: \"*/\"\n                }\n            }\n        }\n    };\n}\nconst $c5f00aa455439ff8$export$ace627bcd07e724c = $c5f00aa455439ff8$var$mkVerilog({});\n// TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\nvar $c5f00aa455439ff8$var$tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"contentSeparator\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variableName.special\",\n    \"@-\": \"variableName.special\",\n    \"@++\": \"variableName.special\",\n    \"@+=\": \"variableName.special\",\n    \"@+=-\": \"variableName.special\",\n    \"@--\": \"variableName.special\",\n    \"@-=\": \"variableName.special\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable\",\n    \"**\": \"variable\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n};\n// Lines starting with these characters define scope (result in indentation).\nvar $c5f00aa455439ff8$var$tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n};\nvar $c5f00aa455439ff8$var$tlvIndentUnit = 3;\nvar $c5f00aa455439ff8$var$tlvTrackStatements = false;\nvar $c5f00aa455439ff8$var$tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\nvar $c5f00aa455439ff8$var$tlvLineIndentationMatch = /^[! ] */;\nvar $c5f00aa455439ff8$var$tlvCommentMatch = /^\\/[\\/\\*]/;\nconst $c5f00aa455439ff8$export$475c26c9187b140d = $c5f00aa455439ff8$var$mkVerilog({\n    hooks: {\n        electricInput: false,\n        // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n        // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n        // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n        //   - M4 tokens\n        //   - TLV scope indentation\n        //   - Statement delimitation (enabled by tlvTrackStatements)\n        token: function(stream, state) {\n            var style = undefined;\n            var match; // Return value of pattern matches.\n            // Set highlighting mode based on code region (TLV or SV).\n            if (stream.sol() && !state.tlvInBlockComment) {\n                // Process region.\n                if (stream.peek() == '\\\\') {\n                    style = \"def\";\n                    stream.skipToEnd();\n                    if (stream.string.match(/\\\\SV/)) state.tlvCodeActive = false;\n                    else if (stream.string.match(/\\\\TLV/)) state.tlvCodeActive = true;\n                }\n                // Correct indentation in the face of a line prefix char.\n                if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match($c5f00aa455439ff8$var$tlvLineIndentationMatch, false))) state.indented = match[0].length;\n                // Compute indentation state:\n                //   o Auto indentation on next line\n                //   o Indentation scope styles\n                var indented = state.indented;\n                var depth = indented / $c5f00aa455439ff8$var$tlvIndentUnit;\n                if (depth <= state.tlvIndentationStyle.length) {\n                    // not deeper than current scope\n                    var blankline = stream.string.length == indented;\n                    var chPos = depth * $c5f00aa455439ff8$var$tlvIndentUnit;\n                    if (chPos < stream.string.length) {\n                        var bodyString = stream.string.slice(chPos);\n                        var ch = bodyString[0];\n                        if ($c5f00aa455439ff8$var$tlvScopePrefixChars[ch] && (match = bodyString.match($c5f00aa455439ff8$var$tlvIdentMatch)) && $c5f00aa455439ff8$var$tlvIdentifierStyle[match[1]]) {\n                            // This line begins scope.\n                            // Next line gets indented one level.\n                            indented += $c5f00aa455439ff8$var$tlvIndentUnit;\n                            // Style the next level of indentation (except non-region keyword identifiers,\n                            //   which are statements themselves)\n                            if (!(ch == \"\\\\\" && chPos > 0)) {\n                                state.tlvIndentationStyle[depth] = $c5f00aa455439ff8$var$tlvScopePrefixChars[ch];\n                                if ($c5f00aa455439ff8$var$tlvTrackStatements) state.statementComment = false;\n                                depth++;\n                            }\n                        }\n                    }\n                    // Clear out deeper indentation levels unless line is blank.\n                    if (!blankline) while(state.tlvIndentationStyle.length > depth)state.tlvIndentationStyle.pop();\n                }\n                // Set next level of indentation.\n                state.tlvNextIndent = indented;\n            }\n            if (state.tlvCodeActive) {\n                // Highlight as TLV.\n                var beginStatement = false;\n                if ($c5f00aa455439ff8$var$tlvTrackStatements) {\n                    // This starts a statement if the position is at the scope level\n                    // and we're not within a statement leading comment.\n                    beginStatement = stream.peek() != \" \" && // not a space\n                    style === undefined && // not a region identifier\n                    !state.tlvInBlockComment && // not in block comment\n                    //!stream.match(tlvCommentMatch, false) && // not comment start\n                    stream.column() == state.tlvIndentationStyle.length * $c5f00aa455439ff8$var$tlvIndentUnit; // at scope level\n                    if (beginStatement) {\n                        if (state.statementComment) // statement already started by comment\n                        beginStatement = false;\n                        state.statementComment = stream.match($c5f00aa455439ff8$var$tlvCommentMatch, false); // comment start\n                    }\n                }\n                var match;\n                if (style !== undefined) ;\n                else if (state.tlvInBlockComment) {\n                    // In a block comment.\n                    if (stream.match(/^.*?\\*\\//)) {\n                        // Exit block comment.\n                        state.tlvInBlockComment = false;\n                        if ($c5f00aa455439ff8$var$tlvTrackStatements && !stream.eol()) // Anything after comment is assumed to be real statement content.\n                        state.statementComment = false;\n                    } else stream.skipToEnd();\n                    style = \"comment\";\n                } else if ((match = stream.match($c5f00aa455439ff8$var$tlvCommentMatch)) && !state.tlvInBlockComment) {\n                    // Start comment.\n                    if (match[0] == \"//\") // Line comment.\n                    stream.skipToEnd();\n                    else // Block comment.\n                    state.tlvInBlockComment = true;\n                    style = \"comment\";\n                } else if (match = stream.match($c5f00aa455439ff8$var$tlvIdentMatch)) {\n                    // looks like an identifier (or identifier prefix)\n                    var prefix = match[1];\n                    var mnemonic = match[2];\n                    if ($c5f00aa455439ff8$var$tlvIdentifierStyle.hasOwnProperty(prefix) && // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n                    (mnemonic.length > 0 || stream.eol())) style = $c5f00aa455439ff8$var$tlvIdentifierStyle[prefix];\n                    else // Just swallow one character and try again.\n                    // This enables subsequent identifier match with preceding symbol character, which\n                    //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n                    //   comment start with preceding symbols.\n                    stream.backUp(stream.current().length - 1);\n                } else if (stream.match(/^\\t+/)) // Highlight tabs, which are illegal.\n                style = \"invalid\";\n                else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) // [:], (), {}, ;.\n                style = \"meta\";\n                else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) // m4 pre proc\n                style = match[1] == \"+\" ? \"keyword.special\" : \"keyword\";\n                else if (stream.match(/^ +/)) // Skip over spaces.\n                {\n                    if (stream.eol()) // Trailing spaces.\n                    style = \"error\";\n                } else if (stream.match(/^[\\w\\d_]+/)) // alpha-numeric token.\n                style = \"number\";\n                else // Eat the next char w/ no formatting.\n                stream.next();\n            } else if (stream.match(/^[mM]4([\\w\\d_]*)/)) // m4 pre proc\n            style = \"keyword\";\n            return style;\n        },\n        indent: function(state) {\n            return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n        },\n        startState: function(state) {\n            state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n            state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n            state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n            state.tlvInBlockComment = false; // True inside /**/ comment.\n            if ($c5f00aa455439ff8$var$tlvTrackStatements) state.statementComment = false; // True inside a statement's header comment.\n        }\n    }\n});\n\n});\n\n\n//# sourceMappingURL=verilog.e5e917cb.js.map\n","function mkVerilog(parserConfig) {\n\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n      \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n      \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n      \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n      \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n      \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n      \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n      \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n      \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n      \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n      \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n      \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n      \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n      \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n      \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n      \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n      \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n      \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n      \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n    name: \"verilog\",\n\n    startState: function(indentUnit) {\n      var state = {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\n                 (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter, cx) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);\n      else return ctx.indented + (closing ? 0 : cx.unit);\n    },\n\n    languageData: {\n      indentOnInput: buildElectricInputRegEx(),\n      commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n    }\n  };\n};\n\nexport const verilog = mkVerilog({})\n\n// TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\nvar tlvIdentifierStyle = {\n  \"|\": \"link\",\n  \">\": \"property\",  // Should condition this off for > TLV 1c.\n  \"$\": \"variable\",\n  \"$$\": \"variable\",\n  \"?$\": \"qualifier\",\n  \"?*\": \"qualifier\",\n  \"-\": \"contentSeparator\",\n  \"/\": \"property\",\n  \"/-\": \"property\",\n  \"@\": \"variableName.special\",\n  \"@-\": \"variableName.special\",\n  \"@++\": \"variableName.special\",\n  \"@+=\": \"variableName.special\",\n  \"@+=-\": \"variableName.special\",\n  \"@--\": \"variableName.special\",\n  \"@-=\": \"variableName.special\",\n  \"%+\": \"tag\",\n  \"%-\": \"tag\",\n  \"%\": \"tag\",\n  \">>\": \"tag\",\n  \"<<\": \"tag\",\n  \"<>\": \"tag\",\n  \"#\": \"tag\",  // Need to choose a style for this.\n  \"^\": \"attribute\",\n  \"^^\": \"attribute\",\n  \"^!\": \"attribute\",\n  \"*\": \"variable\",\n  \"**\": \"variable\",\n  \"\\\\\": \"keyword\",\n  \"\\\"\": \"comment\"\n};\n\n// Lines starting with these characters define scope (result in indentation).\nvar tlvScopePrefixChars = {\n  \"/\": \"beh-hier\",\n  \">\": \"beh-hier\",\n  \"-\": \"phys-hier\",\n  \"|\": \"pipe\",\n  \"?\": \"when\",\n  \"@\": \"stage\",\n  \"\\\\\": \"keyword\"\n};\nvar tlvIndentUnit = 3;\nvar tlvTrackStatements = false;\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\nvar tlvLineIndentationMatch = /^[! ] */;\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\n\nexport const tlv = mkVerilog({\n  hooks: {\n    electricInput: false,\n\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n    //   - M4 tokens\n    //   - TLV scope indentation\n    //   - Statement delimitation (enabled by tlvTrackStatements)\n    token: function(stream, state) {\n      var style = undefined;\n      var match;  // Return value of pattern matches.\n\n      // Set highlighting mode based on code region (TLV or SV).\n      if (stream.sol() && ! state.tlvInBlockComment) {\n        // Process region.\n        if (stream.peek() == '\\\\') {\n          style = \"def\";\n          stream.skipToEnd();\n          if (stream.string.match(/\\\\SV/)) {\n            state.tlvCodeActive = false;\n          } else if (stream.string.match(/\\\\TLV/)){\n            state.tlvCodeActive = true;\n          }\n        }\n        // Correct indentation in the face of a line prefix char.\n        if (state.tlvCodeActive && stream.pos == 0 &&\n            (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n          state.indented = match[0].length;\n        }\n\n        // Compute indentation state:\n        //   o Auto indentation on next line\n        //   o Indentation scope styles\n        var indented = state.indented;\n        var depth = indented / tlvIndentUnit;\n        if (depth <= state.tlvIndentationStyle.length) {\n          // not deeper than current scope\n\n          var blankline = stream.string.length == indented;\n          var chPos = depth * tlvIndentUnit;\n          if (chPos < stream.string.length) {\n            var bodyString = stream.string.slice(chPos);\n            var ch = bodyString[0];\n            if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                                            tlvIdentifierStyle[match[1]])) {\n              // This line begins scope.\n              // Next line gets indented one level.\n              indented += tlvIndentUnit;\n              // Style the next level of indentation (except non-region keyword identifiers,\n              //   which are statements themselves)\n              if (!(ch == \"\\\\\" && chPos > 0)) {\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                if (tlvTrackStatements) {state.statementComment = false;}\n                depth++;\n              }\n            }\n          }\n          // Clear out deeper indentation levels unless line is blank.\n          if (!blankline) {\n            while (state.tlvIndentationStyle.length > depth) {\n              state.tlvIndentationStyle.pop();\n            }\n          }\n        }\n        // Set next level of indentation.\n        state.tlvNextIndent = indented;\n      }\n\n      if (state.tlvCodeActive) {\n        // Highlight as TLV.\n\n        var beginStatement = false;\n        if (tlvTrackStatements) {\n          // This starts a statement if the position is at the scope level\n          // and we're not within a statement leading comment.\n          beginStatement =\n            (stream.peek() != \" \") &&   // not a space\n            (style === undefined) &&    // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n          (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n          if (beginStatement) {\n            if (state.statementComment) {\n              // statement already started by comment\n              beginStatement = false;\n            }\n            state.statementComment =\n              stream.match(tlvCommentMatch, false); // comment start\n          }\n        }\n\n        var match;\n        if (style !== undefined) {\n        } else if (state.tlvInBlockComment) {\n          // In a block comment.\n          if (stream.match(/^.*?\\*\\//)) {\n            // Exit block comment.\n            state.tlvInBlockComment = false;\n            if (tlvTrackStatements && !stream.eol()) {\n              // Anything after comment is assumed to be real statement content.\n              state.statementComment = false;\n            }\n          } else {\n            stream.skipToEnd();\n          }\n          style = \"comment\";\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n          // Start comment.\n          if (match[0] == \"//\") {\n            // Line comment.\n            stream.skipToEnd();\n          } else {\n            // Block comment.\n            state.tlvInBlockComment = true;\n          }\n          style = \"comment\";\n        } else if (match = stream.match(tlvIdentMatch)) {\n          // looks like an identifier (or identifier prefix)\n          var prefix = match[1];\n          var mnemonic = match[2];\n          if (// is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) &&\n              // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            (mnemonic.length > 0 || stream.eol())) {\n            style = tlvIdentifierStyle[prefix];\n          } else {\n            // Just swallow one character and try again.\n            // This enables subsequent identifier match with preceding symbol character, which\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n            //   comment start with preceding symbols.\n            stream.backUp(stream.current().length - 1);\n          }\n        } else if (stream.match(/^\\t+/)) {\n          // Highlight tabs, which are illegal.\n          style = \"invalid\";\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n          // [:], (), {}, ;.\n          style = \"meta\";\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n          // m4 pre proc\n          style = (match[1] == \"+\") ? \"keyword.special\" : \"keyword\";\n        } else if (stream.match(/^ +/)){\n          // Skip over spaces.\n          if (stream.eol()) {\n            // Trailing spaces.\n            style = \"error\";\n          }\n        } else if (stream.match(/^[\\w\\d_]+/)) {\n          // alpha-numeric token.\n          style = \"number\";\n        } else {\n          // Eat the next char w/ no formatting.\n          stream.next();\n        }\n      } else {\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n          // m4 pre proc\n          style = \"keyword\";\n        }\n      }\n      return style;\n    },\n\n    indent: function(state) {\n      return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n    },\n\n    startState: function(state) {\n      state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n      state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n      state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n      state.tlvInBlockComment = false;  // True inside /**/ comment.\n      if (tlvTrackStatements) {\n        state.statementComment = false;  // True inside a statement's header comment.\n      }\n    }\n\n  }\n});\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","$c5f00aa455439ff8$var$mkVerilog","parserConfig","curPunc","curKeyword","statementIndentUnit","dontAlignCalls","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","quote","style","ch","peek","test","next","eatWhile","tokenize","escaped","end","eat","tokenComment","skipToEnd","backUp","match","cur","current","maybeEnd","Context","indented","column","type","align","prev","pushContext","col","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","name","startState","indentUnit","startOfLine","token","ctx","sol","indentation","eatSpace","close","indent","textAfter","cx","fromHook","firstChar","charAt","closing","possibleClosing","unit","languageData","indentOnInput","buildElectricInputRegEx","allClosings","closings","j","push","RegExp","join","commentTokens","line","block","open","Object","defineProperty","get","$c5f00aa455439ff8$export$ace627bcd07e724c","set","s","enumerable","configurable","$c5f00aa455439ff8$var$tlvIdentifierStyle","$c5f00aa455439ff8$var$tlvScopePrefixChars","$c5f00aa455439ff8$var$tlvIdentMatch","$c5f00aa455439ff8$var$tlvLineIndentationMatch","$c5f00aa455439ff8$var$tlvCommentMatch","electricInput","tlvInBlockComment","string","tlvCodeActive","pos","depth","tlvIndentationStyle","blankline","chPos","bodyString","slice","pop","tlvNextIndent","prefix","mnemonic","hasOwnProperty","eol"],"version":3,"file":"verilog.e5e917cb.js.map"}