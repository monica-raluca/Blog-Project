{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/xquery.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"3MoUH\", function(module, exports) {\n\n$parcel$export(module.exports, \"xQuery\", () => $2c092e1303d06fc9$export$e31be4091fae6df6);\n// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar $2c092e1303d06fc9$var$keywords = function() {\n    // convenience functions used to build keywords object\n    function kw(type) {\n        return {\n            type: type,\n            style: \"keyword\"\n        };\n    }\n    var operator = kw(\"operator\"), atom = {\n        type: \"atom\",\n        style: \"atom\"\n    }, punctuation = {\n        type: \"punctuation\",\n        style: null\n    }, qualifier = {\n        type: \"axis_specifier\",\n        style: \"qualifier\"\n    };\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n        ',': punctuation\n    };\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n    var basic = [\n        'after',\n        'all',\n        'allowing',\n        'ancestor',\n        'ancestor-or-self',\n        'any',\n        'array',\n        'as',\n        'ascending',\n        'at',\n        'attribute',\n        'base-uri',\n        'before',\n        'boundary-space',\n        'by',\n        'case',\n        'cast',\n        'castable',\n        'catch',\n        'child',\n        'collation',\n        'comment',\n        'construction',\n        'contains',\n        'content',\n        'context',\n        'copy',\n        'copy-namespaces',\n        'count',\n        'decimal-format',\n        'declare',\n        'default',\n        'delete',\n        'descendant',\n        'descendant-or-self',\n        'descending',\n        'diacritics',\n        'different',\n        'distance',\n        'document',\n        'document-node',\n        'element',\n        'else',\n        'empty',\n        'empty-sequence',\n        'encoding',\n        'end',\n        'entire',\n        'every',\n        'exactly',\n        'except',\n        'external',\n        'first',\n        'following',\n        'following-sibling',\n        'for',\n        'from',\n        'ftand',\n        'ftnot',\n        'ft-option',\n        'ftor',\n        'function',\n        'fuzzy',\n        'greatest',\n        'group',\n        'if',\n        'import',\n        'in',\n        'inherit',\n        'insensitive',\n        'insert',\n        'instance',\n        'intersect',\n        'into',\n        'invoke',\n        'is',\n        'item',\n        'language',\n        'last',\n        'lax',\n        'least',\n        'let',\n        'levels',\n        'lowercase',\n        'map',\n        'modify',\n        'module',\n        'most',\n        'namespace',\n        'next',\n        'no',\n        'node',\n        'nodes',\n        'no-inherit',\n        'no-preserve',\n        'not',\n        'occurs',\n        'of',\n        'only',\n        'option',\n        'order',\n        'ordered',\n        'ordering',\n        'paragraph',\n        'paragraphs',\n        'parent',\n        'phrase',\n        'preceding',\n        'preceding-sibling',\n        'preserve',\n        'previous',\n        'processing-instruction',\n        'relationship',\n        'rename',\n        'replace',\n        'return',\n        'revalidation',\n        'same',\n        'satisfies',\n        'schema',\n        'schema-attribute',\n        'schema-element',\n        'score',\n        'self',\n        'sensitive',\n        'sentence',\n        'sentences',\n        'sequence',\n        'skip',\n        'sliding',\n        'some',\n        'stable',\n        'start',\n        'stemming',\n        'stop',\n        'strict',\n        'strip',\n        'switch',\n        'text',\n        'then',\n        'thesaurus',\n        'times',\n        'to',\n        'transform',\n        'treat',\n        'try',\n        'tumbling',\n        'type',\n        'typeswitch',\n        'union',\n        'unordered',\n        'update',\n        'updating',\n        'uppercase',\n        'using',\n        'validate',\n        'value',\n        'variable',\n        'version',\n        'weight',\n        'when',\n        'where',\n        'wildcards',\n        'window',\n        'with',\n        'without',\n        'word',\n        'words',\n        'xquery'\n    ];\n    for(var i = 0, l = basic.length; i < l; i++)kwObj[basic[i]] = kw(basic[i]);\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = [\n        'xs:anyAtomicType',\n        'xs:anySimpleType',\n        'xs:anyType',\n        'xs:anyURI',\n        'xs:base64Binary',\n        'xs:boolean',\n        'xs:byte',\n        'xs:date',\n        'xs:dateTime',\n        'xs:dateTimeStamp',\n        'xs:dayTimeDuration',\n        'xs:decimal',\n        'xs:double',\n        'xs:duration',\n        'xs:ENTITIES',\n        'xs:ENTITY',\n        'xs:float',\n        'xs:gDay',\n        'xs:gMonth',\n        'xs:gMonthDay',\n        'xs:gYear',\n        'xs:gYearMonth',\n        'xs:hexBinary',\n        'xs:ID',\n        'xs:IDREF',\n        'xs:IDREFS',\n        'xs:int',\n        'xs:integer',\n        'xs:item',\n        'xs:java',\n        'xs:language',\n        'xs:long',\n        'xs:Name',\n        'xs:NCName',\n        'xs:negativeInteger',\n        'xs:NMTOKEN',\n        'xs:NMTOKENS',\n        'xs:nonNegativeInteger',\n        'xs:nonPositiveInteger',\n        'xs:normalizedString',\n        'xs:NOTATION',\n        'xs:numeric',\n        'xs:positiveInteger',\n        'xs:precisionDecimal',\n        'xs:QName',\n        'xs:short',\n        'xs:string',\n        'xs:time',\n        'xs:token',\n        'xs:unsignedByte',\n        'xs:unsignedInt',\n        'xs:unsignedLong',\n        'xs:unsignedShort',\n        'xs:untyped',\n        'xs:untypedAtomic',\n        'xs:yearMonthDuration'\n    ];\n    for(var i = 0, l = types.length; i < l; i++)kwObj[types[i]] = atom;\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = [\n        'eq',\n        'ne',\n        'lt',\n        'le',\n        'gt',\n        'ge',\n        ':=',\n        '=',\n        '>',\n        '>=',\n        '<',\n        '<=',\n        '.',\n        '|',\n        '?',\n        'and',\n        'or',\n        'div',\n        'idiv',\n        'mod',\n        '*',\n        '/',\n        '+',\n        '-'\n    ];\n    for(var i = 0, l = operators.length; i < l; i++)kwObj[operators[i]] = operator;\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\n        \"self::\",\n        \"attribute::\",\n        \"child::\",\n        \"descendant::\",\n        \"descendant-or-self::\",\n        \"parent::\",\n        \"ancestor::\",\n        \"ancestor-or-self::\",\n        \"following::\",\n        \"preceding::\",\n        \"following-sibling::\",\n        \"preceding-sibling::\"\n    ];\n    for(var i = 0, l = axis_specifiers.length; i < l; i++)kwObj[axis_specifiers[i]] = qualifier;\n    return kwObj;\n}();\nfunction $2c092e1303d06fc9$var$chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n}\n// the primary mode tokenizer\nfunction $2c092e1303d06fc9$var$tokenBase(stream, state) {\n    var ch = stream.next(), mightBeFunction = false, isEQName = $2c092e1303d06fc9$var$isEQNameAhead(stream);\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n        if (stream.match(\"!--\", true)) return $2c092e1303d06fc9$var$chain(stream, state, $2c092e1303d06fc9$var$tokenXMLComment);\n        if (stream.match(\"![CDATA\", false)) {\n            state.tokenize = $2c092e1303d06fc9$var$tokenCDATA;\n            return \"tag\";\n        }\n        if (stream.match(\"?\", false)) return $2c092e1303d06fc9$var$chain(stream, state, $2c092e1303d06fc9$var$tokenPreProcessing);\n        var isclose = stream.eat(\"/\");\n        stream.eatSpace();\n        var tagName = \"\", c;\n        while(c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))tagName += c;\n        return $2c092e1303d06fc9$var$chain(stream, state, $2c092e1303d06fc9$var$tokenTag(tagName, isclose));\n    } else if (ch == \"{\") {\n        $2c092e1303d06fc9$var$pushStateStack(state, {\n            type: \"codeblock\"\n        });\n        return null;\n    } else if (ch == \"}\") {\n        $2c092e1303d06fc9$var$popStateStack(state);\n        return null;\n    } else if ($2c092e1303d06fc9$var$isInXmlBlock(state)) {\n        if (ch == \">\") return \"tag\";\n        else if (ch == \"/\" && stream.eat(\">\")) {\n            $2c092e1303d06fc9$var$popStateStack(state);\n            return \"tag\";\n        } else return \"variable\";\n    } else if (/\\d/.test(ch)) {\n        stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n        return \"atom\";\n    } else if (ch === \"(\" && stream.eat(\":\")) {\n        $2c092e1303d06fc9$var$pushStateStack(state, {\n            type: \"comment\"\n        });\n        return $2c092e1303d06fc9$var$chain(stream, state, $2c092e1303d06fc9$var$tokenComment);\n    } else if (!isEQName && (ch === '\"' || ch === \"'\")) return $2c092e1303d06fc9$var$startString(stream, state, ch);\n    else if (ch === \"$\") return $2c092e1303d06fc9$var$chain(stream, state, $2c092e1303d06fc9$var$tokenVariable);\n    else if (ch === \":\" && stream.eat(\"=\")) return \"keyword\";\n    else if (ch === \"(\") {\n        $2c092e1303d06fc9$var$pushStateStack(state, {\n            type: \"paren\"\n        });\n        return null;\n    } else if (ch === \")\") {\n        $2c092e1303d06fc9$var$popStateStack(state);\n        return null;\n    } else if (ch === \"[\") {\n        $2c092e1303d06fc9$var$pushStateStack(state, {\n            type: \"bracket\"\n        });\n        return null;\n    } else if (ch === \"]\") {\n        $2c092e1303d06fc9$var$popStateStack(state);\n        return null;\n    } else {\n        var known = $2c092e1303d06fc9$var$keywords.propertyIsEnumerable(ch) && $2c092e1303d06fc9$var$keywords[ch];\n        // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n        if (isEQName && ch === '\\\"') while(stream.next() !== '\"');\n        if (isEQName && ch === '\\'') while(stream.next() !== '\\'');\n        // gobble up a word if the character is not known\n        if (!known) stream.eatWhile(/[\\w\\$_-]/);\n        // gobble a colon in the case that is a lib func type call fn:doc\n        var foundColon = stream.eat(\":\");\n        // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n        // which should get matched as a keyword\n        if (!stream.eat(\":\") && foundColon) stream.eatWhile(/[\\w\\$_-]/);\n        // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n        if (stream.match(/^[ \\t]*\\(/, false)) mightBeFunction = true;\n        // is the word a keyword?\n        var word = stream.current();\n        known = $2c092e1303d06fc9$var$keywords.propertyIsEnumerable(word) && $2c092e1303d06fc9$var$keywords[word];\n        // if we think it's a function call but not yet known,\n        // set style to variable for now for lack of something better\n        if (mightBeFunction && !known) known = {\n            type: \"function_call\",\n            style: \"def\"\n        };\n        // if the previous word was element, attribute, axis specifier, this word should be the name of that\n        if ($2c092e1303d06fc9$var$isInXmlConstructor(state)) {\n            $2c092e1303d06fc9$var$popStateStack(state);\n            return \"variable\";\n        }\n        // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n        // push the stack so we know to look for it on the next word\n        if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") $2c092e1303d06fc9$var$pushStateStack(state, {\n            type: \"xmlconstructor\"\n        });\n        // if the word is known, return the details of that else just call this a generic 'word'\n        return known ? known.style : \"variable\";\n    }\n}\n// handle comments, including nested\nfunction $2c092e1303d06fc9$var$tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while(ch = stream.next()){\n        if (ch == \")\" && maybeEnd) {\n            if (nestedCount > 0) nestedCount--;\n            else {\n                $2c092e1303d06fc9$var$popStateStack(state);\n                break;\n            }\n        } else if (ch == \":\" && maybeNested) nestedCount++;\n        maybeEnd = ch == \":\";\n        maybeNested = ch == \"(\";\n    }\n    return \"comment\";\n}\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction $2c092e1303d06fc9$var$tokenString(quote, f) {\n    return function(stream, state) {\n        var ch;\n        while(ch = stream.next()){\n            if (ch == quote) {\n                $2c092e1303d06fc9$var$popStateStack(state);\n                if (f) state.tokenize = f;\n                break;\n            } else if (stream.match(\"{\", false) && $2c092e1303d06fc9$var$isInXmlAttributeBlock(state)) {\n                // if we're in a string and in an XML block, allow an embedded code block in an attribute\n                $2c092e1303d06fc9$var$pushStateStack(state, {\n                    type: \"codeblock\"\n                });\n                state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n                return \"string\";\n            }\n        }\n        return \"string\";\n    };\n}\nfunction $2c092e1303d06fc9$var$startString(stream, state, quote, f) {\n    let tokenize = $2c092e1303d06fc9$var$tokenString(quote, f);\n    $2c092e1303d06fc9$var$pushStateStack(state, {\n        type: \"string\",\n        name: quote,\n        tokenize: tokenize\n    });\n    return $2c092e1303d06fc9$var$chain(stream, state, tokenize);\n}\n// tokenizer for variables\nfunction $2c092e1303d06fc9$var$tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if (stream.eat(\"\\\"\")) {\n        while(stream.next() !== '\\\"');\n        stream.eat(\":\");\n    } else {\n        stream.eatWhile(isVariableChar);\n        if (!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n    return \"variable\";\n}\n// tokenizer for XML tags\nfunction $2c092e1303d06fc9$var$tokenTag(name, isclose) {\n    return function(stream, state) {\n        stream.eatSpace();\n        if (isclose && stream.eat(\">\")) {\n            $2c092e1303d06fc9$var$popStateStack(state);\n            state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n            return \"tag\";\n        }\n        // self closing tag without attributes?\n        if (!stream.eat(\"/\")) $2c092e1303d06fc9$var$pushStateStack(state, {\n            type: \"tag\",\n            name: name,\n            tokenize: $2c092e1303d06fc9$var$tokenBase\n        });\n        if (!stream.eat(\">\")) {\n            state.tokenize = $2c092e1303d06fc9$var$tokenAttribute;\n            return \"tag\";\n        } else state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n        return \"tag\";\n    };\n}\n// tokenizer for XML attributes\nfunction $2c092e1303d06fc9$var$tokenAttribute(stream, state) {\n    var ch = stream.next();\n    if (ch == \"/\" && stream.eat(\">\")) {\n        if ($2c092e1303d06fc9$var$isInXmlAttributeBlock(state)) $2c092e1303d06fc9$var$popStateStack(state);\n        if ($2c092e1303d06fc9$var$isInXmlBlock(state)) $2c092e1303d06fc9$var$popStateStack(state);\n        return \"tag\";\n    }\n    if (ch == \">\") {\n        if ($2c092e1303d06fc9$var$isInXmlAttributeBlock(state)) $2c092e1303d06fc9$var$popStateStack(state);\n        return \"tag\";\n    }\n    if (ch == \"=\") return null;\n    // quoted string\n    if (ch == '\"' || ch == \"'\") return $2c092e1303d06fc9$var$startString(stream, state, ch, $2c092e1303d06fc9$var$tokenAttribute);\n    if (!$2c092e1303d06fc9$var$isInXmlAttributeBlock(state)) $2c092e1303d06fc9$var$pushStateStack(state, {\n        type: \"attribute\",\n        tokenize: $2c092e1303d06fc9$var$tokenAttribute\n    });\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n    // the case where the attribute has not value and the tag was closed\n    if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n        $2c092e1303d06fc9$var$popStateStack(state);\n        state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n    }\n    return \"attribute\";\n}\n// handle comments, including nested\nfunction $2c092e1303d06fc9$var$tokenXMLComment(stream, state) {\n    var ch;\n    while(ch = stream.next())if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n        return \"comment\";\n    }\n}\n// handle CDATA\nfunction $2c092e1303d06fc9$var$tokenCDATA(stream, state) {\n    var ch;\n    while(ch = stream.next())if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n        return \"comment\";\n    }\n}\n// handle preprocessing instructions\nfunction $2c092e1303d06fc9$var$tokenPreProcessing(stream, state) {\n    var ch;\n    while(ch = stream.next())if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = $2c092e1303d06fc9$var$tokenBase;\n        return \"processingInstruction\";\n    }\n}\n// functions to test the current context of the state\nfunction $2c092e1303d06fc9$var$isInXmlBlock(state) {\n    return $2c092e1303d06fc9$var$isIn(state, \"tag\");\n}\nfunction $2c092e1303d06fc9$var$isInXmlAttributeBlock(state) {\n    return $2c092e1303d06fc9$var$isIn(state, \"attribute\");\n}\nfunction $2c092e1303d06fc9$var$isInXmlConstructor(state) {\n    return $2c092e1303d06fc9$var$isIn(state, \"xmlconstructor\");\n}\nfunction $2c092e1303d06fc9$var$isInString(state) {\n    return $2c092e1303d06fc9$var$isIn(state, \"string\");\n}\nfunction $2c092e1303d06fc9$var$isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else return false;\n}\nfunction $2c092e1303d06fc9$var$isIn(state, type) {\n    return state.stack.length && state.stack[state.stack.length - 1].type == type;\n}\nfunction $2c092e1303d06fc9$var$pushStateStack(state, newState) {\n    state.stack.push(newState);\n}\nfunction $2c092e1303d06fc9$var$popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n    state.tokenize = reinstateTokenize || $2c092e1303d06fc9$var$tokenBase;\n}\nconst $2c092e1303d06fc9$export$e31be4091fae6df6 = {\n    name: \"xquery\",\n    startState: function() {\n        return {\n            tokenize: $2c092e1303d06fc9$var$tokenBase,\n            cc: [],\n            stack: []\n        };\n    },\n    token: function(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        return style;\n    },\n    languageData: {\n        commentTokens: {\n            block: {\n                open: \"(:\",\n                close: \":)\"\n            }\n        }\n    }\n};\n\n});\n\n\n//# sourceMappingURL=xquery.06eb8471.js.map\n","// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return startString(stream, state, ch);\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == quote) {\n        popStateStack(state);\n        if (f) state.tokenize = f;\n        break;\n      } else if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        pushStateStack(state, { type: \"codeblock\"});\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nfunction startString(stream, state, quote, f) {\n  let tokenize = tokenString(quote, f);\n  pushStateStack(state, { type: \"string\", name: quote, tokenize });\n  return chain(stream, state, tokenize);\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return startString(stream, state, ch, tokenAttribute);\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nexport const xQuery = {\n  name: \"xquery\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","Object","defineProperty","get","$2c092e1303d06fc9$export$e31be4091fae6df6","set","s","enumerable","configurable","$2c092e1303d06fc9$var$keywords","kw","type","style","operator","atom","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","$2c092e1303d06fc9$var$chain","stream","state","f","tokenize","$2c092e1303d06fc9$var$tokenBase","ch","next","mightBeFunction","isEQName","current","match","$2c092e1303d06fc9$var$tokenXMLComment","$2c092e1303d06fc9$var$tokenCDATA","$2c092e1303d06fc9$var$tokenPreProcessing","name","isclose","eat","eatSpace","c","tagName","$2c092e1303d06fc9$var$popStateStack","$2c092e1303d06fc9$var$pushStateStack","$2c092e1303d06fc9$var$tokenAttribute","$2c092e1303d06fc9$var$isIn","test","$2c092e1303d06fc9$var$tokenComment","$2c092e1303d06fc9$var$startString","$2c092e1303d06fc9$var$tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","maybeEnd","maybeNested","nestedCount","quote","$2c092e1303d06fc9$var$isInXmlAttributeBlock","isVariableChar","$2c092e1303d06fc9$var$isInXmlBlock","stack","newState","push","pop","reinstateTokenize","startState","cc","token","languageData","commentTokens","block","open","close"],"version":3,"file":"xquery.06eb8471.js.map"}