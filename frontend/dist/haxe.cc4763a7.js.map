{"mappings":"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","sources":["<anon>","node_modules/@codemirror/legacy-modes/mode/haxe.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire10c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"VdLNG\", function(module, exports) {\n\n$parcel$export(module.exports, \"haxe\", () => $0ac0016a58d9abd4$export$2e90d0ffbee70fc6);\n$parcel$export(module.exports, \"hxml\", () => $0ac0016a58d9abd4$export$ecfeb731a3c826cd);\n// Tokenizer\nfunction $0ac0016a58d9abd4$var$kw(type) {\n    return {\n        type: type,\n        style: \"keyword\"\n    };\n}\nvar $0ac0016a58d9abd4$var$A = $0ac0016a58d9abd4$var$kw(\"keyword a\"), $0ac0016a58d9abd4$var$B = $0ac0016a58d9abd4$var$kw(\"keyword b\"), $0ac0016a58d9abd4$var$C = $0ac0016a58d9abd4$var$kw(\"keyword c\");\nvar $0ac0016a58d9abd4$var$operator = $0ac0016a58d9abd4$var$kw(\"operator\"), $0ac0016a58d9abd4$var$atom = {\n    type: \"atom\",\n    style: \"atom\"\n}, $0ac0016a58d9abd4$var$attribute = {\n    type: \"attribute\",\n    style: \"attribute\"\n};\nvar $0ac0016a58d9abd4$var$type = $0ac0016a58d9abd4$var$kw(\"typedef\");\nvar $0ac0016a58d9abd4$var$keywords = {\n    \"if\": $0ac0016a58d9abd4$var$A,\n    \"while\": $0ac0016a58d9abd4$var$A,\n    \"else\": $0ac0016a58d9abd4$var$B,\n    \"do\": $0ac0016a58d9abd4$var$B,\n    \"try\": $0ac0016a58d9abd4$var$B,\n    \"return\": $0ac0016a58d9abd4$var$C,\n    \"break\": $0ac0016a58d9abd4$var$C,\n    \"continue\": $0ac0016a58d9abd4$var$C,\n    \"new\": $0ac0016a58d9abd4$var$C,\n    \"throw\": $0ac0016a58d9abd4$var$C,\n    \"var\": $0ac0016a58d9abd4$var$kw(\"var\"),\n    \"inline\": $0ac0016a58d9abd4$var$attribute,\n    \"static\": $0ac0016a58d9abd4$var$attribute,\n    \"using\": $0ac0016a58d9abd4$var$kw(\"import\"),\n    \"public\": $0ac0016a58d9abd4$var$attribute,\n    \"private\": $0ac0016a58d9abd4$var$attribute,\n    \"cast\": $0ac0016a58d9abd4$var$kw(\"cast\"),\n    \"import\": $0ac0016a58d9abd4$var$kw(\"import\"),\n    \"macro\": $0ac0016a58d9abd4$var$kw(\"macro\"),\n    \"function\": $0ac0016a58d9abd4$var$kw(\"function\"),\n    \"catch\": $0ac0016a58d9abd4$var$kw(\"catch\"),\n    \"untyped\": $0ac0016a58d9abd4$var$kw(\"untyped\"),\n    \"callback\": $0ac0016a58d9abd4$var$kw(\"cb\"),\n    \"for\": $0ac0016a58d9abd4$var$kw(\"for\"),\n    \"switch\": $0ac0016a58d9abd4$var$kw(\"switch\"),\n    \"case\": $0ac0016a58d9abd4$var$kw(\"case\"),\n    \"default\": $0ac0016a58d9abd4$var$kw(\"default\"),\n    \"in\": $0ac0016a58d9abd4$var$operator,\n    \"never\": $0ac0016a58d9abd4$var$kw(\"property_access\"),\n    \"trace\": $0ac0016a58d9abd4$var$kw(\"trace\"),\n    \"class\": $0ac0016a58d9abd4$var$type,\n    \"abstract\": $0ac0016a58d9abd4$var$type,\n    \"enum\": $0ac0016a58d9abd4$var$type,\n    \"interface\": $0ac0016a58d9abd4$var$type,\n    \"typedef\": $0ac0016a58d9abd4$var$type,\n    \"extends\": $0ac0016a58d9abd4$var$type,\n    \"implements\": $0ac0016a58d9abd4$var$type,\n    \"dynamic\": $0ac0016a58d9abd4$var$type,\n    \"true\": $0ac0016a58d9abd4$var$atom,\n    \"false\": $0ac0016a58d9abd4$var$atom,\n    \"null\": $0ac0016a58d9abd4$var$atom\n};\nvar $0ac0016a58d9abd4$var$isOperatorChar = /[+\\-*&%=<>!?|]/;\nfunction $0ac0016a58d9abd4$var$chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n}\nfunction $0ac0016a58d9abd4$var$toUnescaped(stream, end) {\n    var escaped = false, next;\n    while((next = stream.next()) != null){\n        if (next == end && !escaped) return true;\n        escaped = !escaped && next == \"\\\\\";\n    }\n}\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar $0ac0016a58d9abd4$var$type, $0ac0016a58d9abd4$var$content;\nfunction $0ac0016a58d9abd4$var$ret(tp, style, cont) {\n    $0ac0016a58d9abd4$var$type = tp;\n    $0ac0016a58d9abd4$var$content = cont;\n    return style;\n}\nfunction $0ac0016a58d9abd4$var$haxeTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") return $0ac0016a58d9abd4$var$chain(stream, state, $0ac0016a58d9abd4$var$haxeTokenString(ch));\n    else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) return $0ac0016a58d9abd4$var$ret(ch);\n    else if (ch == \"0\" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return $0ac0016a58d9abd4$var$ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n        return $0ac0016a58d9abd4$var$ret(\"number\", \"number\");\n    } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n        $0ac0016a58d9abd4$var$toUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimsu]/);\n        return $0ac0016a58d9abd4$var$ret(\"regexp\", \"string.special\");\n    } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) return $0ac0016a58d9abd4$var$chain(stream, state, $0ac0016a58d9abd4$var$haxeTokenComment);\n        else if (stream.eat(\"/\")) {\n            stream.skipToEnd();\n            return $0ac0016a58d9abd4$var$ret(\"comment\", \"comment\");\n        } else {\n            stream.eatWhile($0ac0016a58d9abd4$var$isOperatorChar);\n            return $0ac0016a58d9abd4$var$ret(\"operator\", null, stream.current());\n        }\n    } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return $0ac0016a58d9abd4$var$ret(\"conditional\", \"meta\");\n    } else if (ch == \"@\") {\n        stream.eat(/:/);\n        stream.eatWhile(/[\\w_]/);\n        return $0ac0016a58d9abd4$var$ret(\"metadata\", \"meta\");\n    } else if ($0ac0016a58d9abd4$var$isOperatorChar.test(ch)) {\n        stream.eatWhile($0ac0016a58d9abd4$var$isOperatorChar);\n        return $0ac0016a58d9abd4$var$ret(\"operator\", null, stream.current());\n    } else {\n        var word;\n        if (/[A-Z]/.test(ch)) {\n            stream.eatWhile(/[\\w_<>]/);\n            word = stream.current();\n            return $0ac0016a58d9abd4$var$ret(\"type\", \"type\", word);\n        } else {\n            stream.eatWhile(/[\\w_]/);\n            var word = stream.current(), known = $0ac0016a58d9abd4$var$keywords.propertyIsEnumerable(word) && $0ac0016a58d9abd4$var$keywords[word];\n            return known && state.kwAllowed ? $0ac0016a58d9abd4$var$ret(known.type, known.style, word) : $0ac0016a58d9abd4$var$ret(\"variable\", \"variable\", word);\n        }\n    }\n}\nfunction $0ac0016a58d9abd4$var$haxeTokenString(quote) {\n    return function(stream, state) {\n        if ($0ac0016a58d9abd4$var$toUnescaped(stream, quote)) state.tokenize = $0ac0016a58d9abd4$var$haxeTokenBase;\n        return $0ac0016a58d9abd4$var$ret(\"string\", \"string\");\n    };\n}\nfunction $0ac0016a58d9abd4$var$haxeTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while(ch = stream.next()){\n        if (ch == \"/\" && maybeEnd) {\n            state.tokenize = $0ac0016a58d9abd4$var$haxeTokenBase;\n            break;\n        }\n        maybeEnd = ch == \"*\";\n    }\n    return $0ac0016a58d9abd4$var$ret(\"comment\", \"comment\");\n}\n// Parser\nvar $0ac0016a58d9abd4$var$atomicTypes = {\n    \"atom\": true,\n    \"number\": true,\n    \"variable\": true,\n    \"string\": true,\n    \"regexp\": true\n};\nfunction $0ac0016a58d9abd4$var$HaxeLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n}\nfunction $0ac0016a58d9abd4$var$inScope(state, varname) {\n    for(var v = state.localVars; v; v = v.next)if (v.name == varname) return true;\n}\nfunction $0ac0016a58d9abd4$var$parseHaxe(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    $0ac0016a58d9abd4$var$cx.state = state;\n    $0ac0016a58d9abd4$var$cx.stream = stream;\n    $0ac0016a58d9abd4$var$cx.marked = null, $0ac0016a58d9abd4$var$cx.cc = cc;\n    if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n    while(true){\n        var combinator = cc.length ? cc.pop() : $0ac0016a58d9abd4$var$statement;\n        if (combinator(type, content)) {\n            while(cc.length && cc[cc.length - 1].lex)cc.pop()();\n            if ($0ac0016a58d9abd4$var$cx.marked) return $0ac0016a58d9abd4$var$cx.marked;\n            if (type == \"variable\" && $0ac0016a58d9abd4$var$inScope(state, content)) return \"variableName.local\";\n            if (type == \"variable\" && $0ac0016a58d9abd4$var$imported(state, content)) return \"variableName.special\";\n            return style;\n        }\n    }\n}\nfunction $0ac0016a58d9abd4$var$imported(state, typename) {\n    if (/[a-z]/.test(typename.charAt(0))) return false;\n    var len = state.importedtypes.length;\n    for(var i = 0; i < len; i++)if (state.importedtypes[i] == typename) return true;\n}\nfunction $0ac0016a58d9abd4$var$registerimport(importname) {\n    var state = $0ac0016a58d9abd4$var$cx.state;\n    for(var t = state.importedtypes; t; t = t.next)if (t.name == importname) return;\n    state.importedtypes = {\n        name: importname,\n        next: state.importedtypes\n    };\n}\n// Combinator utils\nvar $0ac0016a58d9abd4$var$cx = {\n    state: null,\n    column: null,\n    marked: null,\n    cc: null\n};\nfunction $0ac0016a58d9abd4$var$pass() {\n    for(var i = arguments.length - 1; i >= 0; i--)$0ac0016a58d9abd4$var$cx.cc.push(arguments[i]);\n}\nfunction $0ac0016a58d9abd4$var$cont() {\n    $0ac0016a58d9abd4$var$pass.apply(null, arguments);\n    return true;\n}\nfunction $0ac0016a58d9abd4$var$inList(name, list) {\n    for(var v = list; v; v = v.next)if (v.name == name) return true;\n    return false;\n}\nfunction $0ac0016a58d9abd4$var$register(varname) {\n    var state = $0ac0016a58d9abd4$var$cx.state;\n    if (state.context) {\n        $0ac0016a58d9abd4$var$cx.marked = \"def\";\n        if ($0ac0016a58d9abd4$var$inList(varname, state.localVars)) return;\n        state.localVars = {\n            name: varname,\n            next: state.localVars\n        };\n    } else if (state.globalVars) {\n        if ($0ac0016a58d9abd4$var$inList(varname, state.globalVars)) return;\n        state.globalVars = {\n            name: varname,\n            next: state.globalVars\n        };\n    }\n}\n// Combinators\nvar $0ac0016a58d9abd4$var$defaultVars = {\n    name: \"this\",\n    next: null\n};\nfunction $0ac0016a58d9abd4$var$pushcontext() {\n    if (!$0ac0016a58d9abd4$var$cx.state.context) $0ac0016a58d9abd4$var$cx.state.localVars = $0ac0016a58d9abd4$var$defaultVars;\n    $0ac0016a58d9abd4$var$cx.state.context = {\n        prev: $0ac0016a58d9abd4$var$cx.state.context,\n        vars: $0ac0016a58d9abd4$var$cx.state.localVars\n    };\n}\nfunction $0ac0016a58d9abd4$var$popcontext() {\n    $0ac0016a58d9abd4$var$cx.state.localVars = $0ac0016a58d9abd4$var$cx.state.context.vars;\n    $0ac0016a58d9abd4$var$cx.state.context = $0ac0016a58d9abd4$var$cx.state.context.prev;\n}\n$0ac0016a58d9abd4$var$popcontext.lex = true;\nfunction $0ac0016a58d9abd4$var$pushlex(type, info) {\n    var result = function() {\n        var state = $0ac0016a58d9abd4$var$cx.state;\n        state.lexical = new $0ac0016a58d9abd4$var$HaxeLexical(state.indented, $0ac0016a58d9abd4$var$cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n}\nfunction $0ac0016a58d9abd4$var$poplex() {\n    var state = $0ac0016a58d9abd4$var$cx.state;\n    if (state.lexical.prev) {\n        if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n    }\n}\n$0ac0016a58d9abd4$var$poplex.lex = true;\nfunction $0ac0016a58d9abd4$var$expect(wanted) {\n    function f(type) {\n        if (type == wanted) return $0ac0016a58d9abd4$var$cont();\n        else if (wanted == \";\") return $0ac0016a58d9abd4$var$pass();\n        else return $0ac0016a58d9abd4$var$cont(f);\n    }\n    return f;\n}\nfunction $0ac0016a58d9abd4$var$statement(type) {\n    if (type == \"@\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$metadef);\n    if (type == \"var\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"vardef\"), $0ac0016a58d9abd4$var$vardef1, $0ac0016a58d9abd4$var$expect(\";\"), $0ac0016a58d9abd4$var$poplex);\n    if (type == \"keyword a\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"form\"), $0ac0016a58d9abd4$var$expression, $0ac0016a58d9abd4$var$statement, $0ac0016a58d9abd4$var$poplex);\n    if (type == \"keyword b\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"form\"), $0ac0016a58d9abd4$var$statement, $0ac0016a58d9abd4$var$poplex);\n    if (type == \"{\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"}\"), $0ac0016a58d9abd4$var$pushcontext, $0ac0016a58d9abd4$var$block, $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$popcontext);\n    if (type == \";\") return $0ac0016a58d9abd4$var$cont();\n    if (type == \"attribute\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$maybeattribute);\n    if (type == \"function\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$functiondef);\n    if (type == \"for\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"form\"), $0ac0016a58d9abd4$var$expect(\"(\"), $0ac0016a58d9abd4$var$pushlex(\")\"), $0ac0016a58d9abd4$var$forspec1, $0ac0016a58d9abd4$var$expect(\")\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$statement, $0ac0016a58d9abd4$var$poplex);\n    if (type == \"variable\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"stat\"), $0ac0016a58d9abd4$var$maybelabel);\n    if (type == \"switch\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"form\"), $0ac0016a58d9abd4$var$expression, $0ac0016a58d9abd4$var$pushlex(\"}\", \"switch\"), $0ac0016a58d9abd4$var$expect(\"{\"), $0ac0016a58d9abd4$var$block, $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$poplex);\n    if (type == \"case\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expression, $0ac0016a58d9abd4$var$expect(\":\"));\n    if (type == \"default\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expect(\":\"));\n    if (type == \"catch\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"form\"), $0ac0016a58d9abd4$var$pushcontext, $0ac0016a58d9abd4$var$expect(\"(\"), $0ac0016a58d9abd4$var$funarg, $0ac0016a58d9abd4$var$expect(\")\"), $0ac0016a58d9abd4$var$statement, $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$popcontext);\n    if (type == \"import\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$importdef, $0ac0016a58d9abd4$var$expect(\";\"));\n    if (type == \"typedef\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$typedef);\n    return $0ac0016a58d9abd4$var$pass($0ac0016a58d9abd4$var$pushlex(\"stat\"), $0ac0016a58d9abd4$var$expression, $0ac0016a58d9abd4$var$expect(\";\"), $0ac0016a58d9abd4$var$poplex);\n}\nfunction $0ac0016a58d9abd4$var$expression(type) {\n    if ($0ac0016a58d9abd4$var$atomicTypes.hasOwnProperty(type)) return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \"type\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \"function\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$functiondef);\n    if (type == \"keyword c\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$maybeexpression);\n    if (type == \"(\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\")\"), $0ac0016a58d9abd4$var$maybeexpression, $0ac0016a58d9abd4$var$expect(\")\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \"operator\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expression);\n    if (type == \"[\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"]\"), $0ac0016a58d9abd4$var$commasep($0ac0016a58d9abd4$var$maybeexpression, \"]\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \"{\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"}\"), $0ac0016a58d9abd4$var$commasep($0ac0016a58d9abd4$var$objprop, \"}\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$maybeoperator);\n    return $0ac0016a58d9abd4$var$cont();\n}\nfunction $0ac0016a58d9abd4$var$maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return $0ac0016a58d9abd4$var$pass();\n    return $0ac0016a58d9abd4$var$pass($0ac0016a58d9abd4$var$expression);\n}\nfunction $0ac0016a58d9abd4$var$maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \"operator\" || type == \":\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expression);\n    if (type == \";\") return;\n    if (type == \"(\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\")\"), $0ac0016a58d9abd4$var$commasep($0ac0016a58d9abd4$var$expression, \")\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \".\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$property, $0ac0016a58d9abd4$var$maybeoperator);\n    if (type == \"[\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"]\"), $0ac0016a58d9abd4$var$expression, $0ac0016a58d9abd4$var$expect(\"]\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$maybeoperator);\n}\nfunction $0ac0016a58d9abd4$var$maybeattribute(type) {\n    if (type == \"attribute\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$maybeattribute);\n    if (type == \"function\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$functiondef);\n    if (type == \"var\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$vardef1);\n}\nfunction $0ac0016a58d9abd4$var$metadef(type) {\n    if (type == \":\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$metadef);\n    if (type == \"variable\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$metadef);\n    if (type == \"(\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\")\"), $0ac0016a58d9abd4$var$commasep($0ac0016a58d9abd4$var$metaargs, \")\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$statement);\n}\nfunction $0ac0016a58d9abd4$var$metaargs(type) {\n    if (type == \"variable\") return $0ac0016a58d9abd4$var$cont();\n}\nfunction $0ac0016a58d9abd4$var$importdef(type, value) {\n    if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        $0ac0016a58d9abd4$var$registerimport(value);\n        return $0ac0016a58d9abd4$var$cont();\n    } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$importdef);\n}\nfunction $0ac0016a58d9abd4$var$typedef(type, value) {\n    if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        $0ac0016a58d9abd4$var$registerimport(value);\n        return $0ac0016a58d9abd4$var$cont();\n    } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) return $0ac0016a58d9abd4$var$cont();\n}\nfunction $0ac0016a58d9abd4$var$maybelabel(type) {\n    if (type == \":\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$statement);\n    return $0ac0016a58d9abd4$var$pass($0ac0016a58d9abd4$var$maybeoperator, $0ac0016a58d9abd4$var$expect(\";\"), $0ac0016a58d9abd4$var$poplex);\n}\nfunction $0ac0016a58d9abd4$var$property(type) {\n    if (type == \"variable\") {\n        $0ac0016a58d9abd4$var$cx.marked = \"property\";\n        return $0ac0016a58d9abd4$var$cont();\n    }\n}\nfunction $0ac0016a58d9abd4$var$objprop(type) {\n    if (type == \"variable\") $0ac0016a58d9abd4$var$cx.marked = \"property\";\n    if ($0ac0016a58d9abd4$var$atomicTypes.hasOwnProperty(type)) return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expect(\":\"), $0ac0016a58d9abd4$var$expression);\n}\nfunction $0ac0016a58d9abd4$var$commasep(what, end) {\n    function proceed(type) {\n        if (type == \",\") return $0ac0016a58d9abd4$var$cont(what, proceed);\n        if (type == end) return $0ac0016a58d9abd4$var$cont();\n        return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expect(end));\n    }\n    return function(type) {\n        if (type == end) return $0ac0016a58d9abd4$var$cont();\n        else return $0ac0016a58d9abd4$var$pass(what, proceed);\n    };\n}\nfunction $0ac0016a58d9abd4$var$block(type) {\n    if (type == \"}\") return $0ac0016a58d9abd4$var$cont();\n    return $0ac0016a58d9abd4$var$pass($0ac0016a58d9abd4$var$statement, $0ac0016a58d9abd4$var$block);\n}\nfunction $0ac0016a58d9abd4$var$vardef1(type, value) {\n    if (type == \"variable\") {\n        $0ac0016a58d9abd4$var$register(value);\n        return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$typeuse, $0ac0016a58d9abd4$var$vardef2);\n    }\n    return $0ac0016a58d9abd4$var$cont();\n}\nfunction $0ac0016a58d9abd4$var$vardef2(type, value) {\n    if (value == \"=\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$expression, $0ac0016a58d9abd4$var$vardef2);\n    if (type == \",\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$vardef1);\n}\nfunction $0ac0016a58d9abd4$var$forspec1(type, value) {\n    if (type == \"variable\") {\n        $0ac0016a58d9abd4$var$register(value);\n        return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$forin, $0ac0016a58d9abd4$var$expression);\n    } else return $0ac0016a58d9abd4$var$pass();\n}\nfunction $0ac0016a58d9abd4$var$forin(_type, value) {\n    if (value == \"in\") return $0ac0016a58d9abd4$var$cont();\n}\nfunction $0ac0016a58d9abd4$var$functiondef(type, value) {\n    //function names starting with upper-case letters are recognised as types, so cludging them together here.\n    if (type == \"variable\" || type == \"type\") {\n        $0ac0016a58d9abd4$var$register(value);\n        return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$functiondef);\n    }\n    if (value == \"new\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$functiondef);\n    if (type == \"(\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\")\"), $0ac0016a58d9abd4$var$pushcontext, $0ac0016a58d9abd4$var$commasep($0ac0016a58d9abd4$var$funarg, \")\"), $0ac0016a58d9abd4$var$poplex, $0ac0016a58d9abd4$var$typeuse, $0ac0016a58d9abd4$var$statement, $0ac0016a58d9abd4$var$popcontext);\n}\nfunction $0ac0016a58d9abd4$var$typeuse(type) {\n    if (type == \":\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$typestring);\n}\nfunction $0ac0016a58d9abd4$var$typestring(type) {\n    if (type == \"type\") return $0ac0016a58d9abd4$var$cont();\n    if (type == \"variable\") return $0ac0016a58d9abd4$var$cont();\n    if (type == \"{\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$pushlex(\"}\"), $0ac0016a58d9abd4$var$commasep($0ac0016a58d9abd4$var$typeprop, \"}\"), $0ac0016a58d9abd4$var$poplex);\n}\nfunction $0ac0016a58d9abd4$var$typeprop(type) {\n    if (type == \"variable\") return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$typeuse);\n}\nfunction $0ac0016a58d9abd4$var$funarg(type, value) {\n    if (type == \"variable\") {\n        $0ac0016a58d9abd4$var$register(value);\n        return $0ac0016a58d9abd4$var$cont($0ac0016a58d9abd4$var$typeuse);\n    }\n}\nconst $0ac0016a58d9abd4$export$2e90d0ffbee70fc6 = {\n    name: \"haxe\",\n    startState: function(indentUnit) {\n        var defaulttypes = [\n            \"Int\",\n            \"Float\",\n            \"String\",\n            \"Void\",\n            \"Std\",\n            \"Bool\",\n            \"Dynamic\",\n            \"Array\"\n        ];\n        var state = {\n            tokenize: $0ac0016a58d9abd4$var$haxeTokenBase,\n            reAllowed: true,\n            kwAllowed: true,\n            cc: [],\n            lexical: new $0ac0016a58d9abd4$var$HaxeLexical(-indentUnit, 0, \"block\", false),\n            importedtypes: defaulttypes,\n            context: null,\n            indented: 0\n        };\n        return state;\n    },\n    token: function(stream, state) {\n        if (stream.sol()) {\n            if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n            state.indented = stream.indentation();\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if ($0ac0016a58d9abd4$var$type == \"comment\") return style;\n        state.reAllowed = !!($0ac0016a58d9abd4$var$type == \"operator\" || $0ac0016a58d9abd4$var$type == \"keyword c\" || $0ac0016a58d9abd4$var$type.match(/^[\\[{}\\(,;:]$/));\n        state.kwAllowed = $0ac0016a58d9abd4$var$type != '.';\n        return $0ac0016a58d9abd4$var$parseHaxe(state, style, $0ac0016a58d9abd4$var$type, $0ac0016a58d9abd4$var$content, stream);\n    },\n    indent: function(state, textAfter, cx) {\n        if (state.tokenize != $0ac0016a58d9abd4$var$haxeTokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n        if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n        var type = lexical.type, closing = firstChar == type;\n        if (type == \"vardef\") return lexical.indented + 4;\n        else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n        else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n        else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n        else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n        else return lexical.indented + (closing ? 0 : cx.unit);\n    },\n    languageData: {\n        indentOnInput: /^\\s*[{}]$/,\n        commentTokens: {\n            line: \"//\",\n            block: {\n                open: \"/*\",\n                close: \"*/\"\n            }\n        }\n    }\n};\nconst $0ac0016a58d9abd4$export$ecfeb731a3c826cd = {\n    name: \"hxml\",\n    startState: function() {\n        return {\n            define: false,\n            inString: false\n        };\n    },\n    token: function(stream, state) {\n        var ch = stream.peek();\n        var sol = stream.sol();\n        ///* comments */\n        if (ch == \"#\") {\n            stream.skipToEnd();\n            return \"comment\";\n        }\n        if (sol && ch == \"-\") {\n            var style = \"variable-2\";\n            stream.eat(/-/);\n            if (stream.peek() == \"-\") {\n                stream.eat(/-/);\n                style = \"keyword a\";\n            }\n            if (stream.peek() == \"D\") {\n                stream.eat(/[D]/);\n                style = \"keyword c\";\n                state.define = true;\n            }\n            stream.eatWhile(/[A-Z]/i);\n            return style;\n        }\n        var ch = stream.peek();\n        if (state.inString == false && ch == \"'\") {\n            state.inString = true;\n            stream.next();\n        }\n        if (state.inString == true) {\n            if (stream.skipTo(\"'\")) ;\n            else stream.skipToEnd();\n            if (stream.peek() == \"'\") {\n                stream.next();\n                state.inString = false;\n            }\n            return \"string\";\n        }\n        stream.next();\n        return null;\n    },\n    languageData: {\n        commentTokens: {\n            line: \"#\"\n        }\n    }\n};\n\n});\n\n\n//# sourceMappingURL=haxe.cc4763a7.js.map\n","// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nexport const haxe = {\n  name: \"haxe\",\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nexport const hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRegister","parcelRequire","$parcel$global","globalThis","register","module","exports","$0ac0016a58d9abd4$var$kw","type","style","$0ac0016a58d9abd4$export$2e90d0ffbee70fc6","$0ac0016a58d9abd4$export$ecfeb731a3c826cd","$0ac0016a58d9abd4$var$type","$0ac0016a58d9abd4$var$content","$0ac0016a58d9abd4$var$A","$0ac0016a58d9abd4$var$B","$0ac0016a58d9abd4$var$C","$0ac0016a58d9abd4$var$operator","$0ac0016a58d9abd4$var$atom","$0ac0016a58d9abd4$var$attribute","$0ac0016a58d9abd4$var$keywords","$0ac0016a58d9abd4$var$isOperatorChar","$0ac0016a58d9abd4$var$chain","stream","state","f","tokenize","$0ac0016a58d9abd4$var$toUnescaped","end","next","escaped","$0ac0016a58d9abd4$var$haxeTokenBase","word","ch","quote","cont","test","eat","eatWhile","match","reAllowed","$0ac0016a58d9abd4$var$haxeTokenComment","skipToEnd","current","tp","known","propertyIsEnumerable","kwAllowed","maybeEnd","$0ac0016a58d9abd4$var$atomicTypes","$0ac0016a58d9abd4$var$HaxeLexical","indented","column","align","prev","info","$0ac0016a58d9abd4$var$registerimport","importname","$0ac0016a58d9abd4$var$cx","t","importedtypes","name","marked","cc","$0ac0016a58d9abd4$var$pass","i","arguments","length","push","$0ac0016a58d9abd4$var$cont","apply","$0ac0016a58d9abd4$var$inList","list","$0ac0016a58d9abd4$var$register","varname","context","localVars","globalVars","$0ac0016a58d9abd4$var$defaultVars","$0ac0016a58d9abd4$var$pushcontext","vars","$0ac0016a58d9abd4$var$popcontext","$0ac0016a58d9abd4$var$pushlex","result","lexical","lex","$0ac0016a58d9abd4$var$poplex","$0ac0016a58d9abd4$var$expect","wanted","$0ac0016a58d9abd4$var$statement","$0ac0016a58d9abd4$var$metadef","$0ac0016a58d9abd4$var$vardef1","$0ac0016a58d9abd4$var$expression","$0ac0016a58d9abd4$var$block","$0ac0016a58d9abd4$var$maybeattribute","$0ac0016a58d9abd4$var$functiondef","$0ac0016a58d9abd4$var$forspec1","$0ac0016a58d9abd4$var$maybelabel","$0ac0016a58d9abd4$var$funarg","$0ac0016a58d9abd4$var$importdef","$0ac0016a58d9abd4$var$typedef","hasOwnProperty","$0ac0016a58d9abd4$var$maybeoperator","$0ac0016a58d9abd4$var$maybeexpression","$0ac0016a58d9abd4$var$commasep","$0ac0016a58d9abd4$var$objprop","value","$0ac0016a58d9abd4$var$property","$0ac0016a58d9abd4$var$metaargs","charAt","what","proceed","$0ac0016a58d9abd4$var$typeuse","$0ac0016a58d9abd4$var$vardef2","$0ac0016a58d9abd4$var$forin","_type","$0ac0016a58d9abd4$var$typestring","$0ac0016a58d9abd4$var$typeprop","startState","indentUnit","token","sol","indentation","eatSpace","content","combinator","pop","$0ac0016a58d9abd4$var$inScope","$0ac0016a58d9abd4$var$imported","typename","len","indent","textAfter","cx","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","block","open","close","define","inString","peek","skipTo"],"version":3,"file":"haxe.cc4763a7.js.map"}